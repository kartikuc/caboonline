<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>CABO ‚Äî Online Card Game</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=Playfair+Display:wght@400;700;900&family=DM+Mono:wght@300;400;500&display=swap');

  :root {
    --bg: #0a0a0f;
    --surface: #13131a;
    --surface2: #1e1e2a;
    --border: #2a2a3a;
    --accent: #c8a96e;
    --accent2: #e8c98e;
    --red: #e05555;
    --green: #55b87a;
    --blue: #5599e0;
    --purple: #9966cc;
    --text: #e8e8f0;
    --muted: #888899;
    --card-w: 52px;
    --card-h: 72px;
  }

  * { box-sizing: border-box; margin: 0; padding: 0; }
  html, body { height: 100%; overflow: hidden; }

  body {
    background: var(--bg);
    color: var(--text);
    font-family: 'DM Mono', monospace;
    height: 100vh;
  }

  /* ‚îÄ‚îÄ‚îÄ LOBBY ‚îÄ‚îÄ‚îÄ */
  #lobby {
    display: flex; flex-direction: column; align-items: center; justify-content: center;
    height: 100vh; gap: 24px; padding: 24px;
    background: radial-gradient(ellipse at 50% 0%, #1a1428 0%, var(--bg) 70%);
    overflow-y: auto;
  }

  .logo {
    font-family: 'Playfair Display', serif;
    font-size: clamp(48px, 8vw, 80px);
    font-weight: 900;
    letter-spacing: 0.15em;
    color: var(--accent);
    text-shadow: 0 0 60px rgba(200,169,110,0.3);
  }
  .logo::after {
    content: 'CARD GAME';
    display: block;
    font-size: 0.18em;
    letter-spacing: 0.5em;
    color: var(--muted);
    text-align: center;
    font-family: 'DM Mono', monospace;
    font-weight: 300;
    margin-top: 4px;
  }

  .lobby-box {
    background: var(--surface);
    border: 1px solid var(--border);
    border-radius: 16px;
    padding: 26px;
    width: 100%;
    max-width: 400px;
    display: flex; flex-direction: column; gap: 13px;
  }

  .lobby-box h2 { font-family: 'Playfair Display', serif; font-size: 20px; color: var(--accent); }
  label { font-size: 10px; letter-spacing: 0.1em; color: var(--muted); text-transform: uppercase; }

  input[type=text] {
    width: 100%; padding: 10px 13px;
    background: var(--surface2); border: 1px solid var(--border);
    border-radius: 8px; color: var(--text); font-family: 'DM Mono', monospace;
    font-size: 14px; outline: none; transition: border-color 0.2s;
  }
  input[type=text]:focus { border-color: var(--accent); }

  .btn {
    padding: 10px 18px; border-radius: 8px; border: none;
    font-family: 'DM Mono', monospace; font-size: 12px; font-weight: 500;
    cursor: pointer; transition: all 0.15s; letter-spacing: 0.05em;
  }
  .btn-primary { background: var(--accent); color: #0a0a0f; }
  .btn-primary:hover { background: var(--accent2); transform: translateY(-1px); }
  .btn-secondary { background: var(--surface2); color: var(--text); border: 1px solid var(--border); }
  .btn-secondary:hover { border-color: var(--accent); color: var(--accent); }
  .btn:disabled { opacity: 0.4; cursor: not-allowed; transform: none !important; }

  .divider { display: flex; align-items: center; gap: 10px; color: var(--muted); font-size: 10px; }
  .divider::before, .divider::after { content: ''; flex: 1; height: 1px; background: var(--border); }

  .room-code-display {
    background: var(--surface2); border: 1px dashed var(--accent);
    border-radius: 8px; padding: 13px; text-align: center;
  }
  .room-code-display .code { font-size: 28px; letter-spacing: 0.3em; color: var(--accent); font-family: 'Playfair Display', serif; font-weight: 700; }
  .room-code-display .hint { font-size: 10px; color: var(--muted); margin-top: 4px; }

  .player-list { display: flex; flex-direction: column; gap: 6px; }
  .player-item {
    display: flex; align-items: center; gap: 8px;
    padding: 8px 11px; background: var(--surface2); border-radius: 7px;
    border: 1px solid var(--border); font-size: 12px;
  }
  .player-item.me { border-color: var(--accent); }
  .player-dot { width: 7px; height: 7px; border-radius: 50%; background: var(--green); flex-shrink: 0; }
  .player-item .host-badge { margin-left: auto; font-size: 9px; color: var(--accent); }

  .power-legend {
    display: flex; flex-wrap: wrap; gap: 3px; justify-content: center;
    font-size: 9px;
  }
  .pl-item { padding: 2px 5px; border-radius: 4px; border: 1px solid var(--border); color: var(--muted); }
  .pl-peek { border-color: rgba(85,184,122,0.4); color: #55b87a; }
  .pl-spy { border-color: rgba(85,153,224,0.4); color: #5599e0; }
  .pl-swap { border-color: rgba(153,102,204,0.4); color: #9966cc; }
  .pl-king { border-color: rgba(200,169,110,0.4); color: var(--accent); }

  /* ‚îÄ‚îÄ‚îÄ GAME LAYOUT ‚Äî fixed viewport ‚îÄ‚îÄ‚îÄ */
  #game {
    display: none;
    height: 100vh;
    flex-direction: column;
    overflow: hidden;
  }

  .game-header {
    display: flex; align-items: center; justify-content: space-between;
    padding: 7px 14px; background: var(--surface);
    border-bottom: 1px solid var(--border); flex-shrink: 0;
  }
  .game-title { font-family: 'Playfair Display', serif; font-size: 18px; color: var(--accent); }
  .turn-info { font-size: 10px; color: var(--muted); text-align: center; }
  #turn-label { font-size: 12px; }

  .score-strip {
    display: flex; gap: 5px; padding: 5px 12px; background: var(--surface2);
    border-bottom: 1px solid var(--border); overflow-x: auto; flex-shrink: 0;
  }
  .score-badge {
    display: flex; flex-direction: column; align-items: center;
    padding: 3px 10px; background: var(--surface); border-radius: 6px;
    border: 1px solid var(--border); min-width: 64px; flex-shrink: 0;
    font-size: 9px; gap: 1px;
  }
  .score-badge.active-player { border-color: var(--accent); }
  .score-badge .sname { color: var(--muted); overflow: hidden; white-space: nowrap; max-width: 70px; text-overflow: ellipsis; }
  .score-badge .sval { color: var(--text); font-size: 14px; font-family: 'Playfair Display', serif; }

  /* main area = board + chat */
  .game-main {
    flex: 1; display: flex; overflow: hidden; min-height: 0;
  }

  /* ‚îÄ‚îÄ‚îÄ BOARD ‚îÄ‚îÄ‚îÄ */
  .game-board {
    flex: 1; display: flex; flex-direction: column;
    gap: 8px; padding: 8px 10px; overflow-y: auto; min-height: 0;
  }

  .opponents-area { display: flex; flex-wrap: wrap; gap: 7px; justify-content: center; }

  .opponent-zone {
    background: var(--surface); border: 1px solid var(--border);
    border-radius: 9px; padding: 8px; min-width: 130px;
    display: flex; flex-direction: column; gap: 6px; align-items: center;
  }
  .opponent-zone.active-turn { border-color: var(--accent); box-shadow: 0 0 14px rgba(200,169,110,0.15); }
  .opponent-name { font-size: 10px; color: var(--muted); }

  /* center */
  .center-area {
    display: flex; align-items: center; justify-content: center; gap: 16px; flex-wrap: wrap;
  }
  .pile-container { display: flex; flex-direction: column; align-items: center; gap: 4px; }
  .pile-label { font-size: 8px; letter-spacing: 0.15em; color: var(--muted); text-transform: uppercase; }

  /* ‚îÄ‚îÄ‚îÄ CARD ‚îÄ‚îÄ‚îÄ */
  .card {
    width: var(--card-w); height: var(--card-h);
    border-radius: 7px; border: 1px solid var(--border);
    cursor: pointer; transition: all 0.15s;
    display: flex; align-items: center; justify-content: center;
    position: relative; user-select: none; flex-shrink: 0;
    font-family: 'Playfair Display', serif;
  }
  .card.face-down {
    background: linear-gradient(135deg, #1e1e35 0%, #2a2a45 50%, #1e1e35 100%);
  }
  .card.face-down::after { content: '‚ú¶'; color: var(--accent); opacity: 0.3; font-size: 17px; }
  .card.face-up {
    background: #f5f0e8; color: #1a1a1a;
    flex-direction: column; justify-content: space-between; padding: 4px;
  }
  .card.face-up.red-suit { color: #c0392b; }
  .card-corner { font-size: 10px; font-weight: 700; line-height: 1; }
  .card-center { font-size: 16px; }
  .card-corner.bottom { align-self: flex-end; transform: rotate(180deg); }

  .card.peek-card { box-shadow: inset 0 0 0 2px rgba(85,184,122,0.6); }
  .card.spy-card { box-shadow: inset 0 0 0 2px rgba(85,153,224,0.6); }
  .card.swap-card { box-shadow: inset 0 0 0 2px rgba(153,102,204,0.6); }
  .card.king-card { box-shadow: inset 0 0 0 2px rgba(200,169,110,0.8); }

  .card:hover:not(.not-selectable) { transform: translateY(-3px); box-shadow: 0 6px 14px rgba(0,0,0,0.4); }
  .card.selected { transform: translateY(-5px) !important; box-shadow: 0 0 0 2px var(--accent), 0 8px 18px rgba(0,0,0,0.5) !important; }
  .card.selectable:hover { border-color: var(--accent); }
  .card.not-selectable { cursor: default; }
  .card.not-selectable:hover { transform: none !important; box-shadow: none !important; }

  /* 2√ó2 grid */
  .hand-grid {
    display: grid;
    grid-template-columns: repeat(2, var(--card-w));
    grid-template-rows: repeat(2, var(--card-h));
    gap: 4px;
  }

  .deck-card {
    background: linear-gradient(135deg, #1e1e35 0%, #2a2a45 100%);
    position: relative; overflow: hidden;
  }
  .deck-card::before {
    content: attr(data-count);
    position: absolute; bottom: 3px; right: 5px;
    font-size: 8px; color: var(--accent); opacity: 0.7;
    font-family: 'DM Mono', monospace;
  }
  .discard-empty {
    width: var(--card-w); height: var(--card-h);
    border-radius: 7px; border: 2px dashed var(--border);
    display: flex; align-items: center; justify-content: center;
    color: var(--border); font-size: 16px;
  }

  /* my area */
  .my-area {
    background: var(--surface); border: 1px solid var(--border);
    border-radius: 9px; padding: 8px;
    display: flex; flex-direction: column; gap: 6px; align-items: center;
  }
  .my-area.my-turn { border-color: var(--accent); }

  /* drawn card */
  .drawn-area {
    display: flex; flex-direction: column; align-items: center; gap: 4px;
    padding: 8px; background: var(--surface2); border-radius: 8px;
    border: 1px dashed var(--border);
  }
  .drawn-area-label { font-size: 8px; color: var(--muted); letter-spacing: 0.1em; text-transform: uppercase; }

  /* log */
  .log-panel {
    max-height: 50px; overflow-y: auto; width: 100%;
    display: flex; flex-direction: column-reverse; gap: 2px;
  }
  .log-entry { font-size: 9px; color: var(--muted); }
  .log-entry .lname { color: var(--accent); }

  /* ‚îÄ‚îÄ‚îÄ CHAT ‚îÄ‚îÄ‚îÄ */
  .chat-panel {
    width: 210px; flex-shrink: 0;
    display: flex; flex-direction: column;
    border-left: 1px solid var(--border);
    background: var(--surface);
    overflow: hidden;
  }
  .chat-header {
    padding: 7px 11px; border-bottom: 1px solid var(--border);
    font-size: 9px; letter-spacing: 0.12em; color: var(--muted); text-transform: uppercase;
    flex-shrink: 0;
  }
  .chat-messages {
    flex: 1; overflow-y: auto; padding: 7px 9px;
    display: flex; flex-direction: column; gap: 5px;
  }
  .chat-msg { font-size: 10px; line-height: 1.4; }
  .chat-msg .cname { color: var(--accent); font-size: 9px; }
  .chat-msg.me .cname { color: var(--accent2); }
  .chat-msg .cbody { color: var(--text); word-break: break-word; }
  .chat-msg.system .cbody { color: var(--muted); font-style: italic; }
  .chat-input-area {
    padding: 7px 9px; border-top: 1px solid var(--border);
    display: flex; gap: 5px; flex-shrink: 0;
  }
  .chat-input-area input {
    flex: 1; padding: 6px 8px; background: var(--surface2);
    border: 1px solid var(--border); border-radius: 6px;
    color: var(--text); font-family: 'DM Mono', monospace; font-size: 10px;
    outline: none;
  }
  .chat-input-area input:focus { border-color: var(--accent); }
  .chat-send-btn {
    padding: 6px 9px; background: var(--accent); color: #0a0a0f;
    border: none; border-radius: 6px; cursor: pointer; font-size: 11px;
    transition: background 0.15s;
  }
  .chat-send-btn:hover { background: var(--accent2); }

  /* ‚îÄ‚îÄ‚îÄ BOTTOM BAR ‚îÄ‚îÄ‚îÄ */
  .bottom-bar {
    display: flex; align-items: center; justify-content: space-between;
    padding: 5px 12px; background: var(--surface2);
    border-top: 1px solid var(--border); flex-shrink: 0; gap: 8px;
    min-height: 40px;
  }
  .help-text { font-size: 10px; color: var(--muted); flex: 1; }

  .btn-action { font-size: 10px; padding: 7px 12px; white-space: nowrap; }
  .btn-danger { background: rgba(224,85,85,0.15); color: var(--red); border: 1px solid rgba(224,85,85,0.3); }
  .btn-danger:hover:not(:disabled) { background: rgba(224,85,85,0.25); border-color: var(--red); }
  .btn-success { background: rgba(85,184,122,0.15); color: var(--green); border: 1px solid rgba(85,184,122,0.3); }
  .btn-success:hover { background: rgba(85,184,122,0.25); border-color: var(--green); }

  /* ‚îÄ‚îÄ‚îÄ MODAL ‚îÄ‚îÄ‚îÄ */
  .modal-overlay {
    position: fixed; inset: 0; background: rgba(0,0,0,0.75);
    display: flex; align-items: center; justify-content: center;
    z-index: 100; backdrop-filter: blur(4px);
    opacity: 0; pointer-events: none; transition: opacity 0.2s;
  }
  .modal-overlay.open { opacity: 1; pointer-events: all; }
  .modal {
    background: var(--surface); border: 1px solid var(--border);
    border-radius: 13px; padding: 24px; max-width: 360px; width: 90%;
    text-align: center; display: flex; flex-direction: column; gap: 12px;
    transform: scale(0.95); transition: transform 0.2s; max-height: 88vh; overflow-y: auto;
  }
  .modal-overlay.open .modal { transform: scale(1); }
  .modal h2 { font-family: 'Playfair Display', serif; font-size: 22px; color: var(--accent); }
  .modal p { font-size: 11px; color: var(--muted); line-height: 1.6; }
  .score-table { text-align: left; font-size: 11px; width: 100%; }
  .score-row { display: flex; justify-content: space-between; padding: 5px 0; border-bottom: 1px solid var(--border); gap: 8px; }
  .score-row.winner { color: var(--green); }

  .status-chip { padding: 3px 7px; border-radius: 20px; font-size: 9px; display: inline-block; }
  .chip-cabo { background: rgba(200,169,110,0.15); color: var(--accent); border: 1px solid var(--accent); }

  /* loading */
  .loading-overlay {
    position: fixed; inset: 0; background: var(--bg);
    display: flex; flex-direction: column; align-items: center; justify-content: center;
    z-index: 200; gap: 14px;
  }
  .spinner { width: 34px; height: 34px; border: 3px solid var(--border); border-top-color: var(--accent); border-radius: 50%; animation: spin 0.8s linear infinite; }

  @keyframes pulse { 0%,100%{opacity:1}50%{opacity:0.5} }
  .pulsing { animation: pulse 1.5s ease-in-out infinite; }
  @keyframes spin { to { transform: rotate(360deg); } }
</style>
</head>
<body>

<div class="loading-overlay" id="loading">
  <div style="font-family:'Playfair Display',serif;font-size:36px;color:var(--accent)">CABO</div>
  <div class="spinner"></div>
  <div style="font-size:10px;color:var(--muted)">Connecting...</div>
</div>

<!-- LOBBY -->
<div id="lobby" style="display:none">
  <div class="logo">CABO</div>

  <div class="lobby-box" id="enter-name-box">
    <h2>Welcome</h2>
    <div>
      <label>Your Name</label>
      <input type="text" id="player-name-input" placeholder="Enter your name..." maxlength="20" />
    </div>
    <button class="btn btn-primary" onclick="setName()">Continue ‚Üí</button>
  </div>

  <div class="lobby-box" id="lobby-main" style="display:none">
    <h2>Play Cabo</h2>
    <button class="btn btn-primary" onclick="createRoom()">üé≤ Create New Room</button>
    <div class="divider">or join existing</div>
    <div>
      <label>Room Code</label>
      <input type="text" id="join-code-input" placeholder="4-letter code..." maxlength="4"
        style="text-transform:uppercase;letter-spacing:0.2em;font-size:16px" />
    </div>
    <button class="btn btn-secondary" onclick="joinRoom()">Join Room ‚Üí</button>
    <div class="power-legend">
      <span class="pl-item pl-peek">7/8 Peek own</span>
      <span class="pl-item pl-spy">9/10 Spy opp.</span>
      <span class="pl-item pl-swap">J Blind Swap</span>
      <span class="pl-item pl-swap">Q Peek opp+Swap</span>
      <span class="pl-item pl-king">K Peek both+Swap</span>
      <span class="pl-item pl-king">K‚ô† = 0 pts</span>
    </div>
  </div>

  <div class="lobby-box" id="waiting-room" style="display:none">
    <h2>Room Ready</h2>
    <div class="room-code-display">
      <div class="code" id="display-room-code">ABCD</div>
      <div class="hint">Share this code with friends</div>
    </div>
    <div>
      <label style="margin-bottom:5px;display:block">Players (<span id="player-count">1</span>/6)</label>
      <div class="player-list" id="player-list"></div>
    </div>
    <button class="btn btn-primary" id="start-btn" onclick="startGame()" disabled>Start Game (need 2+)</button>
    <button class="btn btn-secondary" onclick="leaveRoom()">‚Üê Leave</button>
  </div>
</div>

<!-- GAME -->
<div id="game">
  <div class="game-header">
    <div class="game-title">CABO</div>
    <div class="turn-info">
      <div id="turn-label" class="pulsing">Loading...</div>
      <div id="round-label" style="font-size:9px;color:var(--muted);margin-top:1px">Round 1</div>
    </div>
    <div id="cabo-status"></div>
  </div>

  <div class="score-strip" id="score-strip"></div>

  <div class="game-main">
    <!-- Board -->
    <div class="game-board">
      <div class="opponents-area" id="opponents-area"></div>

      <div class="center-area">
        <div class="pile-container">
          <div class="pile-label">Draw Pile</div>
          <div class="card deck-card face-down" id="deck-pile" data-count="" onclick="drawFromDeck()">
            <span style="color:var(--accent);opacity:0.3;font-size:17px">‚ú¶</span>
          </div>
        </div>

        <div id="drawn-card-area" style="display:none">
          <div class="drawn-area">
            <div class="drawn-area-label">Drawn Card</div>
            <div class="card face-up" id="drawn-card-display" style="cursor:default"></div>
            <div style="display:flex;gap:4px;margin-top:3px;flex-wrap:wrap;justify-content:center">
              <button class="btn btn-secondary btn-action" onclick="discardDrawnCard()">Discard</button>
              <button class="btn btn-success btn-action" id="use-power-btn" onclick="usePower()" style="display:none">Use Power</button>
            </div>
          </div>
        </div>

        <div class="pile-container">
          <div class="pile-label">Discard Pile</div>
          <div id="discard-pile-display"><div class="discard-empty">+</div></div>
        </div>
      </div>

      <div class="my-area" id="my-area">
        <div style="font-size:9px;color:var(--muted)" id="my-name-label">You</div>
        <div class="hand-grid" id="my-cards"></div>
      </div>

      <div class="log-panel" id="log-panel"></div>
    </div>

    <!-- Chat -->
    <div class="chat-panel">
      <div class="chat-header">üí¨ Chat</div>
      <div class="chat-messages" id="chat-messages"></div>
      <div class="chat-input-area">
        <input type="text" id="chat-input" placeholder="Message..." maxlength="120" />
        <button class="chat-send-btn" onclick="sendChat()">‚Üë</button>
      </div>
    </div>
  </div>

  <div class="bottom-bar">
    <div class="help-text" id="help-text">Waiting...</div>
    <button class="btn btn-action btn-danger" id="cabo-btn" onclick="callCabo()">üì£ Call CABO</button>
  </div>
</div>

<!-- Modals -->
<div class="modal-overlay" id="round-modal">
  <div class="modal">
    <h2>Round Over!</h2>
    <div id="round-modal-content"></div>
    <button class="btn btn-primary" id="next-round-btn" onclick="nextRound()" style="display:none">Next Round ‚Üí</button>
    <button class="btn btn-secondary" onclick="closeRoundModal()">Close</button>
  </div>
</div>

<div class="modal-overlay" id="game-over-modal">
  <div class="modal">
    <h2 id="gameover-title">Game Over!</h2>
    <div id="gameover-content"></div>
    <button class="btn btn-primary" onclick="playAgain()">Play Again</button>
  </div>
</div>

<script type="module">
import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-app.js";
import { getDatabase, ref, set, get, update, onValue, push, remove, off }
  from "https://www.gstatic.com/firebasejs/10.12.2/firebase-database.js";

// ‚ïê‚ïê PASTE YOUR FIREBASE CONFIG HERE ‚ïê‚ïê
const firebaseConfig = {
  apiKey: "AIzaSyDvuECKAQvX4WY9UwBYHXrkGcivcBKwd8c",
  authDomain: "cabo-1611d.firebaseapp.com",
  databaseURL: "https://cabo-1611d-default-rtdb.firebaseio.com",
  projectId: "cabo-1611d",
  storageBucket: "cabo-1611d.firebasestorage.app",
  messagingSenderId: "507007893312",
  appId: "1:507007893312:web:139152ef2e57c7235584a5"
};

const app = initializeApp(firebaseConfig);
const db = getDatabase(app);

// ‚ïê‚ïê STATE ‚ïê‚ïê
let myId = null, myName = '', roomCode = null, roomRef = null;
let gameState = null, isHost = false;
let pendingAction = null;
let initialPeekCount = 0, initialPeekDone = false;
const myKnownCards = new Map(); // pos ‚Üí card

const SUITS = ['‚ô†','‚ô•','‚ô¶','‚ô£'];
const SUIT_RED = new Set(['‚ô•','‚ô¶']);

// ‚îÄ‚îÄ Deck builder ‚îÄ‚îÄ
// K‚ô† = 0 pts (but still face=13), all others face=value
// Joker = 0 pts
function buildDeck() {
  const deck = [];
  for (let f = 1; f <= 13; f++) {
    for (const s of SUITS) {
      const value = (f === 13 && s === '‚ô†') ? 0 : f;
      deck.push({ face: f, suit: s, value });
    }
  }
  deck.push({ face: 0, suit: '‚òÖ', value: 0 });
  deck.push({ face: 0, suit: '‚òÖ', value: 0 });
  return deck;
}

function shuffle(arr) {
  const a = [...arr];
  for (let i = a.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [a[i], a[j]] = [a[j], a[i]];
  }
  return a;
}

function cardPower(card) {
  if (!card) return null;
  const f = card.face ?? card.value;
  if (f === 7 || f === 8) return 'peek';
  if (f === 9 || f === 10) return 'spy';
  if (f === 11) return 'blindswap';
  if (f === 12) return 'peekswap';
  if (f === 13) return 'kingswap';
  return null;
}

function cardDisplay(card) {
  if (!card) return { label: '?', suit: '', isRed: false };
  const f = card.face ?? card.value;
  let label = String(f);
  if (!f || card.suit === '‚òÖ') label = '‚òÖ';
  if (f === 1) label = 'A';
  if (f === 11) label = 'J';
  if (f === 12) label = 'Q';
  if (f === 13) label = 'K';
  return { label, suit: card.suit || '', isRed: SUIT_RED.has(card.suit) };
}

function makeCardEl(card, opts = {}) {
  const el = document.createElement('div');
  el.className = 'card';
  if (!card || opts.faceDown) { el.classList.add('face-down'); return el; }
  el.classList.add('face-up');
  const d = cardDisplay(card);
  if (d.isRed) el.classList.add('red-suit');
  const p = cardPower(card);
  if (p === 'peek') el.classList.add('peek-card');
  else if (p === 'spy') el.classList.add('spy-card');
  else if (p === 'blindswap' || p === 'peekswap') el.classList.add('swap-card');
  else if (p === 'kingswap') el.classList.add('king-card');
  el.innerHTML = `<span class="card-corner">${d.label}</span><span class="card-center">${d.suit}</span><span class="card-corner bottom">${d.label}</span>`;
  return el;
}

// ‚ïê‚ïê LOBBY ‚ïê‚ïê
function showScreen(id) {
  document.getElementById('loading').style.display = 'none';
  document.getElementById('lobby').style.display = id === 'lobby' ? 'flex' : 'none';
  document.getElementById('game').style.display = id === 'game' ? 'flex' : 'none';
}

window.setName = function() {
  const n = document.getElementById('player-name-input').value.trim();
  if (!n) return;
  myName = n;
  document.getElementById('enter-name-box').style.display = 'none';
  document.getElementById('lobby-main').style.display = 'flex';
};

window.createRoom = async function() {
  const code = Array.from({length:4}, () => 'ABCDEFGHJKLMNPQRSTUVWXYZ'[Math.floor(Math.random()*23)]).join('');
  roomCode = code; isHost = true;
  await joinRoomWithCode(code);
};

window.joinRoom = async function() {
  const code = document.getElementById('join-code-input').value.trim().toUpperCase();
  if (code.length !== 4) return alert('Enter a 4-letter room code');
  const snap = await get(ref(db, `rooms/${code}`));
  if (!snap.exists()) return alert('Room not found');
  if (snap.val().state !== 'lobby') return alert('Game already started');
  roomCode = code; isHost = false;
  await joinRoomWithCode(code);
};

async function joinRoomWithCode(code) {
  roomRef = ref(db, `rooms/${code}`);
  const playerRef = push(ref(db, `rooms/${code}/players`));
  myId = playerRef.key;
  const snap = await get(ref(db, `rooms/${code}/players`));
  const count = Object.keys(snap.val() || {}).length;
  await set(playerRef, { name: myName, id: myId, score: 0 });
  if (count === 0) {
    await set(ref(db, `rooms/${code}/state`), 'lobby');
    await set(ref(db, `rooms/${code}/host`), myId);
  }
  document.getElementById('display-room-code').textContent = code;
  document.getElementById('lobby-main').style.display = 'none';
  document.getElementById('waiting-room').style.display = 'flex';
  listenLobby();
}

function listenLobby() {
  const pr = ref(db, `rooms/${roomCode}/players`);
  onValue(pr, snap => {
    const arr = Object.values(snap.val() || {});
    document.getElementById('player-count').textContent = arr.length;
    const list = document.getElementById('player-list');
    list.innerHTML = '';
    arr.forEach(p => {
      const div = document.createElement('div');
      div.className = 'player-item' + (p.id === myId ? ' me' : '');
      div.innerHTML = `<div class="player-dot"></div><span>${p.name}</span>${p.id === arr[0]?.id ? '<span class="host-badge">HOST</span>' : ''}`;
      list.appendChild(div);
    });
    const sb = document.getElementById('start-btn');
    sb.disabled = arr.length < 2 || arr[0]?.id !== myId;
    sb.textContent = arr.length < 2 ? 'Start Game (need 2+)' : `Start Game (${arr.length} players)`;
  });
  const sr = ref(db, `rooms/${roomCode}/state`);
  onValue(sr, snap => { if (snap.val() === 'playing') { off(sr); initGame(); } });
}

window.leaveRoom = function() {
  if (roomCode && myId) remove(ref(db, `rooms/${roomCode}/players/${myId}`));
  location.reload();
};

window.startGame = async function() {
  if (!isHost) return;
  const snap = await get(ref(db, `rooms/${roomCode}/players`));
  const playersObj = snap.val();
  const playerArr = Object.values(playersObj);
  const deck = shuffle(buildDeck());
  const hands = {};
  playerArr.forEach(p => { hands[p.id] = [deck.shift(), deck.shift(), deck.shift(), deck.shift()]; });
  const discard = deck.shift();
  const state = {
    deck, discard: [discard], hands,
    playerOrder: playerArr.map(p => p.id),
    playerNames: Object.fromEntries(playerArr.map(p => [p.id, p.name])),
    scores: Object.fromEntries(playerArr.map(p => [p.id, 0])),
    currentTurn: playerArr[0].id,
    caboCallerId: null, lastTurns: {},
    phase: 'initial-peek', drawnCard: null, round: 1, log: []
  };
  await set(roomRef, { state: 'playing', players: playersObj, host: myId, game: state });
};

// ‚ïê‚ïê GAME ‚ïê‚ïê
function initGame() {
  showScreen('game');
  onValue(ref(db, `rooms/${roomCode}/game`), snap => {
    if (!snap.exists()) return;
    gameState = snap.val();
    fixArrays(gameState);
    renderGame();
  });
  onValue(ref(db, `rooms/${roomCode}/chat`), snap => {
    if (!snap.exists()) return;
    const arr = Object.values(snap.val());
    const container = document.getElementById('chat-messages');
    container.innerHTML = '';
    arr.slice(-80).forEach(m => {
      const div = document.createElement('div');
      div.className = 'chat-msg' + (m.id === myId ? ' me' : '') + (m.system ? ' system' : '');
      div.innerHTML = m.system
        ? `<span class="cbody">${m.text}</span>`
        : `<div class="cname">${m.name}</div><div class="cbody">${esc(m.text)}</div>`;
      container.appendChild(div);
    });
    container.scrollTop = container.scrollHeight;
  });
}

function fixArrays(gs) {
  if (gs.deck && !Array.isArray(gs.deck)) gs.deck = Object.values(gs.deck);
  if (gs.playerOrder && !Array.isArray(gs.playerOrder)) gs.playerOrder = Object.values(gs.playerOrder);
  if (gs.discard && !Array.isArray(gs.discard)) gs.discard = Object.values(gs.discard);
  if (gs.log && !Array.isArray(gs.log)) gs.log = Object.values(gs.log);
  (gs.playerOrder || []).forEach(pid => {
    if (gs.hands?.[pid] && !Array.isArray(gs.hands[pid])) gs.hands[pid] = Object.values(gs.hands[pid]);
  });
}

const isMyTurn = () => gameState?.currentTurn === myId;

function renderGame() {
  if (!gameState) return;
  const gs = gameState;
  const myTurn = isMyTurn();
  const currentName = gs.playerNames?.[gs.currentTurn] || '?';

  // Header
  const tl = document.getElementById('turn-label');
  tl.textContent = myTurn ? '‚ú® Your Turn' : `${currentName}'s Turn`;
  tl.style.color = myTurn ? 'var(--accent2)' : 'var(--text)';
  document.getElementById('round-label').textContent = `Round ${gs.round || 1}`;
  document.getElementById('cabo-status').innerHTML = gs.caboCallerId
    ? `<span class="status-chip chip-cabo">CABO ‚Äî ${gs.playerNames[gs.caboCallerId]}</span>` : '';

  // Scores
  const strip = document.getElementById('score-strip');
  strip.innerHTML = '';
  (gs.playerOrder || []).forEach(pid => {
    const div = document.createElement('div');
    div.className = 'score-badge' + (pid === gs.currentTurn ? ' active-player' : '');
    div.innerHTML = `<span class="sname">${gs.playerNames[pid]}${pid === myId ? ' ‚òÖ' : ''}</span><span class="sval">${gs.scores?.[pid] ?? 0}</span>`;
    strip.appendChild(div);
  });

  // Opponents
  const oppArea = document.getElementById('opponents-area');
  oppArea.innerHTML = '';
  (gs.playerOrder || []).filter(pid => pid !== myId).forEach(pid => {
    const zone = document.createElement('div');
    zone.className = 'opponent-zone' + (pid === gs.currentTurn ? ' active-turn' : '');
    const hand = gs.hands?.[pid] || [];
    const grid = document.createElement('div');
    grid.className = 'hand-grid';
    hand.forEach((c, i) => {
      let showFace = false;
      const pa = pendingAction;
      if (pa?.oppId === pid && pa?.oppPos === i) {
        if ((pa.type === 'spy' && pa.step === 'revealed') ||
            (pa.type === 'peekswap' && (pa.step === 'peek-done' || pa.step === 'pick-mine')) ||
            (pa.type === 'kingswap' && (pa.step === 'peek-done' || pa.step === 'peek-mine' || pa.step === 'pick-mine' || pa.step === 'pick-opp-swap'))) {
          showFace = true;
        }
      }
      const el = makeCardEl(c, { faceDown: !showFace });
      const pa2 = pendingAction;
      if (myTurn && pa2) {
        if ((pa2.type === 'spy' && pa2.step === 'pick-opp') ||
            (pa2.type === 'peekswap' && pa2.step === 'pick-opp') ||
            (pa2.type === 'kingswap' && pa2.step === 'pick-opp') ||
            (pa2.type === 'kingswap' && pa2.step === 'pick-opp-swap') ||
            (pa2.type === 'blindswap' && pa2.step === 'pick-opp')) {
          el.classList.add('selectable');
          el.onclick = () => handleOppCardClick(pid, i);
        } else {
          el.classList.add('not-selectable');
        }
      } else {
        el.classList.add('not-selectable');
      }
      grid.appendChild(el);
    });
    zone.innerHTML = `<div class="opponent-name">${gs.playerNames[pid]}</div>`;
    zone.appendChild(grid);
    oppArea.appendChild(zone);
  });

  // Deck
  const deckEl = document.getElementById('deck-pile');
  deckEl.dataset.count = (gs.deck || []).length;
  deckEl.style.opacity = (gs.deck || []).length === 0 ? '0.3' : '1';
  deckEl.style.cursor = (myTurn && gs.phase === 'play' && !gs.drawnCard && !pendingAction) ? 'pointer' : 'default';

  // Discard
  const discardArr = gs.discard || [];
  const top = discardArr[discardArr.length - 1] || null;
  const dd = document.getElementById('discard-pile-display');
  if (top) {
    const el = makeCardEl(top); el.classList.add('not-selectable');
    dd.innerHTML = ''; dd.appendChild(el);
  } else {
    dd.innerHTML = '<div class="discard-empty">+</div>';
  }

  // Drawn card
  const drawnArea = document.getElementById('drawn-card-area');
  if (gs.drawnCard && myTurn && !pendingAction) {
    drawnArea.style.display = 'block';
    const d = cardDisplay(gs.drawnCard);
    const dDisp = document.getElementById('drawn-card-display');
    const p = cardPower(gs.drawnCard);
    dDisp.className = 'card face-up' + (d.isRed ? ' red-suit' : '')
      + (p === 'peek' ? ' peek-card' : p === 'spy' ? ' spy-card' : (p === 'blindswap' || p === 'peekswap') ? ' swap-card' : p === 'kingswap' ? ' king-card' : '');
    dDisp.innerHTML = `<span class="card-corner">${d.label}</span><span class="card-center">${d.suit}</span><span class="card-corner bottom">${d.label}</span>`;
    const pb = document.getElementById('use-power-btn');
    if (p) {
      pb.style.display = 'block';
      pb.textContent = { peek:'üëÅ Peek Own', spy:'üîç Spy Opp.', blindswap:'üîÑ Blind Swap', peekswap:'üëÅüîÑ Peek+Swap', kingswap:'üëë King Swap' }[p];
    } else { pb.style.display = 'none'; }
  } else { drawnArea.style.display = 'none'; }

  // My hand ‚Äî 2√ó2
  const myHand = gs.hands?.[myId] || [];
  const myCardsEl = document.getElementById('my-cards');
  myCardsEl.innerHTML = '';
  document.getElementById('my-name-label').textContent = myName + ' (you)';
  document.getElementById('my-area').className = 'my-area' + (myTurn ? ' my-turn' : '');

  myHand.forEach((card, i) => {
    const known = myKnownCards.has(i);
    const pa = pendingAction;
    const kingShowMine = pa?.type === 'kingswap' && (pa.step === 'peek-mine') && pa.myPos === i;
    const el = (known || kingShowMine) ? makeCardEl(card) : makeCardEl(card, { faceDown: true });

    if (gs.phase === 'initial-peek' && !initialPeekDone) {
      // Only allow bottom 2 (indices 2,3)
      if (i === 2 || i === 3) {
        el.classList.add('selectable');
        el.onclick = () => doInitialPeek(i, card);
      } else {
        el.classList.add('not-selectable');
      }
    } else if (gs.phase === 'play' && myTurn) {
      const pa = pendingAction;
      if (gs.drawnCard && !pa) {
        el.classList.add('selectable'); el.title = 'Swap in drawn card';
        el.onclick = () => swapWithMyCard(i);
      } else if (pa?.type === 'peek' && pa.step === 'pick') {
        el.classList.add('selectable'); el.onclick = () => doPeekReveal(i, card);
      } else if (pa?.type === 'blindswap' && pa.step === 'pick-mine') {
        el.classList.add('selectable'); el.onclick = () => { pendingAction.myPos = i; pendingAction.step = 'pick-opp'; renderGame(); };
      } else if (pa?.type === 'peekswap' && pa.step === 'pick-mine') {
        el.classList.add('selectable'); el.onclick = () => doPeekswapPickMine(i);
      } else if (pa?.type === 'kingswap' && pa.step === 'pick-mine') {
        el.classList.add('selectable'); el.onclick = () => doKingswapPickMine(i);
      } else { el.classList.add('not-selectable'); }
      if (pa?.myPos === i) el.classList.add('selected');
    } else { el.classList.add('not-selectable'); }

    myCardsEl.appendChild(el);
  });

  // Help
  document.getElementById('help-text').textContent = helpText(gs, myTurn, currentName);

  // Cabo btn
  document.getElementById('cabo-btn').disabled =
    !myTurn || !!gs.caboCallerId || gs.phase !== 'play' || !!gs.drawnCard || !!pendingAction;

  // Log
  const logPanel = document.getElementById('log-panel');
  logPanel.innerHTML = '';
  (gs.log || []).slice(-5).reverse().forEach(e => {
    const div = document.createElement('div');
    div.className = 'log-entry';
    div.innerHTML = e;
    logPanel.appendChild(div);
  });

  if (gs.phase === 'round-end') showRoundEnd();
  if (gs.phase === 'game-over' && !document.getElementById('game-over-modal').classList.contains('open'))
    showGameOverModal(gs.scores, gs.playerNames, gs.playerOrder);
}

function helpText(gs, myTurn, currentName) {
  if (gs.phase === 'initial-peek') return `Click your 2 BOTTOM cards to peek (${2-initialPeekCount} left)`;
  if (!myTurn) return `Waiting for ${currentName}...`;
  const pa = pendingAction;
  if (!gs.drawnCard && !pa) return 'Draw a card, or call CABO!';
  if (gs.drawnCard && !pa) return 'Discard or click one of your cards to swap it in';
  if (!pa) return '';
  const m = {
    'peek:pick': 'üëÅ Click one of YOUR cards to peek at it',
    'spy:pick-opp': 'üîç Click an OPPONENT\'S card to spy on it',
    'spy:revealed': 'üîç Peeked! Ending turn...',
    'blindswap:pick-mine': 'üîÑ Pick YOUR card to swap',
    'blindswap:pick-opp': 'üîÑ Pick an OPPONENT\'S card to swap with',
    'peekswap:pick-opp': 'üëÅüîÑ Pick OPPONENT\'S card to peek at',
    'peekswap:peek-done': 'üëÅüîÑ Now pick YOUR card to swap out',
    'peekswap:pick-mine': 'üëÅüîÑ Pick YOUR card to swap out',
    'kingswap:pick-opp': 'üëë Pick OPPONENT\'S card to peek at',
    'kingswap:peek-done': 'üëë Now pick YOUR card to peek at',
    'kingswap:pick-mine': 'üëë Click YOUR card to peek at it',
    'kingswap:peek-mine': 'üëë Now pick OPPONENT\'S card to swap with yours',
    'kingswap:pick-opp-swap': 'üëë Pick OPPONENT\'S card to swap',
  };
  return m[`${pa.type}:${pa.step}`] || '';
}

// ‚îÄ‚îÄ Opponent card click router ‚îÄ‚îÄ
function handleOppCardClick(oppId, pos) {
  const pa = pendingAction;
  if (!pa) return;
  if (pa.type === 'spy' && pa.step === 'pick-opp') doSpyReveal(oppId, pos);
  else if (pa.type === 'peekswap' && pa.step === 'pick-opp') doPeekswapPickOpp(oppId, pos);
  else if (pa.type === 'kingswap' && pa.step === 'pick-opp') doKingswapPickOpp(oppId, pos);
  else if (pa.type === 'kingswap' && pa.step === 'pick-opp-swap') doKingswapSwap(oppId, pos);
  else if (pa.type === 'blindswap' && pa.step === 'pick-opp') doBlindswapFinish(oppId, pos);
}

// ‚îÄ‚îÄ Initial Peek (bottom 2 cards = index 2,3) ‚îÄ‚îÄ
function doInitialPeek(pos, card) {
  if (initialPeekCount >= 2 || initialPeekDone) return;
  initialPeekCount++;
  myKnownCards.set(pos, card);
  renderGame();
  // Auto-hide after 3s
  setTimeout(() => { myKnownCards.delete(pos); renderGame(); }, 3000);
  if (initialPeekCount >= 2) {
    initialPeekDone = true;
    update(ref(db, `rooms/${roomCode}/game/peekReady`), { [myId]: true });
    setTimeout(async () => {
      const snap = await get(ref(db, `rooms/${roomCode}/game/peekReady`));
      const ready = snap.val() || {};
      if ((gameState.playerOrder || []).every(pid => ready[pid]))
        await update(ref(db, `rooms/${roomCode}/game`), { phase: 'play' });
    }, 500);
    if (isHost) setTimeout(async () => {
      const snap = await get(ref(db, `rooms/${roomCode}/game/phase`));
      if (snap.val() === 'initial-peek') await update(ref(db, `rooms/${roomCode}/game`), { phase: 'play' });
    }, 10000);
  }
}

// ‚îÄ‚îÄ Draw ‚îÄ‚îÄ
window.drawFromDeck = async function() {
  if (!isMyTurn() || gameState.phase !== 'play' || gameState.drawnCard || pendingAction) return;
  const gs = gameState;
  if (!gs.deck?.length) return;
  const deck = [...gs.deck];
  const drawn = deck.shift();
  await update(ref(db, `rooms/${roomCode}/game`), {
    deck, drawnCard: drawn,
    log: addLog(gs.log, `<span class="lname">${myName}</span> drew a card`)
  });
};

// ‚îÄ‚îÄ Discard ‚îÄ‚îÄ
window.discardDrawnCard = async function() {
  if (!isMyTurn() || !gameState.drawnCard) return;
  const gs = gameState;
  const d = cardDisplay(gs.drawnCard);
  const updates = {
    drawnCard: null,
    discard: [...(gs.discard||[]), gs.drawnCard],
    log: addLog(gs.log, `<span class="lname">${myName}</span> discarded ${d.label}${d.suit}`)
  };
  Object.assign(updates, nextTurn(gs));
  await update(ref(db, `rooms/${roomCode}/game`), updates);
};

// ‚îÄ‚îÄ Use Power ‚îÄ‚îÄ
window.usePower = function() {
  if (!isMyTurn() || !gameState.drawnCard) return;
  const power = cardPower(gameState.drawnCard);
  if (!power) return;
  pendingAction = { type: power, drawnCard: gameState.drawnCard, step: firstStep(power) };
  renderGame();
};

function firstStep(p) {
  return { peek:'pick', spy:'pick-opp', blindswap:'pick-mine', peekswap:'pick-opp', kingswap:'pick-opp' }[p] || 'pick';
}

// ‚îÄ‚îÄ Peek Own (7/8) ‚îÄ‚îÄ
function doPeekReveal(pos, card) {
  myKnownCards.set(pos, card);
  const d = cardDisplay(card);
  showToast(`Card ${pos+1}: ${d.label}${d.suit} = ${card.value}pts`, 2500);
  setTimeout(() => { myKnownCards.delete(pos); renderGame(); }, 2500);
  const gs = gameState;
  const updates = {
    drawnCard: null,
    discard: [...(gs.discard||[]), pendingAction.drawnCard],
    log: addLog(gs.log, `<span class="lname">${myName}</span> peeked at their own card`)
  };
  pendingAction = null;
  Object.assign(updates, nextTurn(gs));
  update(ref(db, `rooms/${roomCode}/game`), updates);
}

// ‚îÄ‚îÄ Spy (9/10) ‚îÄ‚îÄ
function doSpyReveal(oppId, oppPos) {
  const gs = gameState;
  const card = gs.hands[oppId][oppPos];
  const d = cardDisplay(card);
  const opName = gs.playerNames[oppId];
  pendingAction = { ...pendingAction, step: 'revealed', oppId, oppPos };
  renderGame();
  showToast(`${opName} Card ${oppPos+1}: ${d.label}${d.suit} = ${card.value}pts`, 2500);
  setTimeout(async () => {
    const dc = pendingAction?.drawnCard || gs.drawnCard;
    const updates = {
      drawnCard: null,
      discard: [...(gameState.discard||[]), dc],
      log: addLog(gameState.log, `<span class="lname">${myName}</span> spied on ${opName}'s card`)
    };
    pendingAction = null;
    Object.assign(updates, nextTurn(gameState));
    await update(ref(db, `rooms/${roomCode}/game`), updates);
  }, 2200);
}

// ‚îÄ‚îÄ Blind Swap (J) ‚îÄ‚îÄ
async function doBlindswapFinish(oppId, oppPos) {
  const gs = gameState;
  const myHand = [...gs.hands[myId]];
  const oppHand = [...gs.hands[oppId]];
  const myPos = pendingAction.myPos;
  [myHand[myPos], oppHand[oppPos]] = [oppHand[oppPos], myHand[myPos]];
  myKnownCards.delete(myPos);
  const opName = gs.playerNames[oppId];
  const updates = {
    drawnCard: null,
    discard: [...(gs.discard||[]), pendingAction.drawnCard],
    [`hands/${myId}`]: myHand,
    [`hands/${oppId}`]: oppHand,
    log: addLog(gs.log, `<span class="lname">${myName}</span> blind-swapped with ${opName}`)
  };
  pendingAction = null;
  Object.assign(updates, nextTurn(gs));
  await update(ref(db, `rooms/${roomCode}/game`), updates);
}

// ‚îÄ‚îÄ Peek+Swap (Q) ‚îÄ‚îÄ
function doPeekswapPickOpp(oppId, oppPos) {
  const gs = gameState;
  const card = gs.hands[oppId][oppPos];
  const d = cardDisplay(card);
  const opName = gs.playerNames[oppId];
  pendingAction = { ...pendingAction, step: 'peek-done', oppId, oppPos };
  showToast(`${opName} Card ${oppPos+1}: ${d.label}${d.suit} ‚Äî now pick YOUR card to swap`, 3000);
  renderGame();
  setTimeout(() => { if (pendingAction) { pendingAction.step = 'pick-mine'; renderGame(); } }, 2200);
}

async function doPeekswapPickMine(myPos) {
  const gs = gameState;
  const myHand = [...gs.hands[myId]];
  const oppHand = [...gs.hands[pendingAction.oppId]];
  const oppPos = pendingAction.oppPos;
  const oppCard = oppHand[oppPos];
  [myHand[myPos], oppHand[oppPos]] = [oppHand[oppPos], myHand[myPos]];
  myKnownCards.set(myPos, oppCard); // I know what I swapped in
  const opName = gs.playerNames[pendingAction.oppId];
  const updates = {
    drawnCard: null,
    discard: [...(gs.discard||[]), pendingAction.drawnCard],
    [`hands/${myId}`]: myHand,
    [`hands/${pendingAction.oppId}`]: oppHand,
    log: addLog(gs.log, `<span class="lname">${myName}</span> peeked & swapped with ${opName}`)
  };
  pendingAction = null;
  Object.assign(updates, nextTurn(gs));
  await update(ref(db, `rooms/${roomCode}/game`), updates);
}

// ‚îÄ‚îÄ King Swap (K) ‚îÄ‚îÄ
function doKingswapPickOpp(oppId, oppPos) {
  const gs = gameState;
  const card = gs.hands[oppId][oppPos];
  const d = cardDisplay(card);
  const opName = gs.playerNames[oppId];
  pendingAction = { ...pendingAction, step: 'peek-done', oppId, oppPos };
  showToast(`${opName} Card ${oppPos+1}: ${d.label}${d.suit} ‚Äî now pick YOUR card to peek`, 3000);
  renderGame();
  setTimeout(() => { if (pendingAction) { pendingAction.step = 'pick-mine'; renderGame(); } }, 2200);
}

function doKingswapPickMine(myPos) {
  const gs = gameState;
  const myCard = gs.hands[myId][myPos];
  const d = cardDisplay(myCard);
  pendingAction = { ...pendingAction, step: 'peek-mine', myPos };
  myKnownCards.set(myPos, myCard);
  showToast(`Your Card ${myPos+1}: ${d.label}${d.suit} ‚Äî pick OPPONENT card to swap`, 3000);
  renderGame();
  setTimeout(() => { if (pendingAction) { pendingAction.step = 'pick-opp-swap'; myKnownCards.delete(myPos); renderGame(); } }, 2200);
}

async function doKingswapSwap(oppId, oppPos) {
  const gs = gameState;
  const myHand = [...gs.hands[myId]];
  const oppHand = [...gs.hands[oppId]];
  const myPos = pendingAction.myPos;
  const oppCard = oppHand[oppPos];
  [myHand[myPos], oppHand[oppPos]] = [oppHand[oppPos], myHand[myPos]];
  myKnownCards.set(myPos, oppCard);
  const opName = gs.playerNames[oppId];
  const updates = {
    drawnCard: null,
    discard: [...(gs.discard||[]), pendingAction.drawnCard],
    [`hands/${myId}`]: myHand,
    [`hands/${oppId}`]: oppHand,
    log: addLog(gs.log, `<span class="lname">${myName}</span> used King swap with ${opName}`)
  };
  pendingAction = null;
  Object.assign(updates, nextTurn(gs));
  await update(ref(db, `rooms/${roomCode}/game`), updates);
}

// ‚îÄ‚îÄ Swap drawn into hand ‚îÄ‚îÄ
window.swapWithMyCard = async function(pos) {
  if (!isMyTurn() || !gameState.drawnCard) return;
  const gs = gameState;
  const myHand = [...gs.hands[myId]];
  const oldCard = myHand[pos];
  myHand[pos] = gs.drawnCard;
  const d = cardDisplay(gs.drawnCard);
  myKnownCards.set(pos, gs.drawnCard);
  const updates = {
    drawnCard: null,
    discard: [...(gs.discard||[]), oldCard],
    [`hands/${myId}`]: myHand,
    log: addLog(gs.log, `<span class="lname">${myName}</span> swapped ${d.label}${d.suit} into hand`)
  };
  Object.assign(updates, nextTurn(gs));
  await update(ref(db, `rooms/${roomCode}/game`), updates);
};

// ‚îÄ‚îÄ Call CABO ‚îÄ‚îÄ
window.callCabo = async function() {
  if (!isMyTurn() || gameState.caboCallerId || gameState.phase !== 'play' || pendingAction) return;
  const gs = gameState;
  const lastTurns = {};
  gs.playerOrder.forEach(pid => { if (pid !== myId) lastTurns[pid] = 1; });
  const updates = {
    caboCallerId: myId, lastTurns,
    log: addLog(gs.log, `<span class="lname">${myName}</span> <span style="color:var(--accent)">called CABO! üéØ</span>`)
  };
  Object.assign(updates, nextTurn(gs));
  await update(ref(db, `rooms/${roomCode}/game`), updates);
};

function nextTurn(gs) {
  const order = gs.playerOrder;
  const nextPid = order[(order.indexOf(gs.currentTurn) + 1) % order.length];
  if (gs.caboCallerId) {
    const lt = { ...(gs.lastTurns || {}) };
    if (lt[gs.currentTurn] !== undefined) lt[gs.currentTurn]--;
    const nonCaller = order.filter(pid => pid !== gs.caboCallerId);
    const allDone = nonCaller.every(pid => !lt[pid] || lt[pid] <= 0);
    if (allDone) return { currentTurn: nextPid, phase: 'round-end', lastTurns: lt };
    return { currentTurn: nextPid, lastTurns: lt };
  }
  return { currentTurn: nextPid };
}

function addLog(existing, entry) {
  const logs = [...(existing || [])];
  logs.push(entry);
  if (logs.length > 25) logs.shift();
  return logs;
}

// ‚îÄ‚îÄ Round End ‚îÄ‚îÄ
function showRoundEnd() {
  if (document.getElementById('round-modal').classList.contains('open')) return;
  const gs = gameState;
  const results = gs.playerOrder.map(pid => {
    const hand = gs.hands[pid] || [];
    const total = hand.reduce((s, c) => s + (c?.value ?? 0), 0);
    return { pid, name: gs.playerNames[pid], hand, total };
  }).sort((a,b) => a.total - b.total);
  const lowest = results[0].total;
  const cabo = gs.caboCallerId;
  const scored = results.map(r => {
    let pts = r.total;
    if (r.pid === cabo) pts = r.total === lowest ? 0 : r.total + 10;
    return { ...r, pts };
  });
  const newScores = { ...(gs.scores || {}) };
  scored.forEach(r => { newScores[r.pid] = (newScores[r.pid] || 0) + r.pts; });
  const gameOver = Object.values(newScores).some(s => s >= 100);
  let html = '<div class="score-table">';
  scored.forEach(r => {
    const handStr = r.hand.map(c => { const d = cardDisplay(c); return `${d.label}${d.suit}(${c.value})`; }).join(' ');
    html += `<div class="score-row ${r.pts === 0 ? 'winner' : ''}">
      <span style="font-size:10px">${r.name}${r.pid===cabo?' üì£':''}: ${handStr}</span>
      <span style="white-space:nowrap">+${r.pts}‚Üí${newScores[r.pid]}</span>
    </div>`;
  });
  html += '</div>';
  document.getElementById('round-modal-content').innerHTML = html;
  document.getElementById('next-round-btn').style.display = (isHost && !gameOver) ? 'block' : 'none';
  document.getElementById('round-modal').classList.add('open');
  if (isHost) update(ref(db, `rooms/${roomCode}/game`), { scores: newScores, phase: gameOver ? 'game-over' : 'round-end' });
}

function showGameOverModal(scores, names, order) {
  document.getElementById('round-modal').classList.remove('open');
  const sorted = order.map(pid => ({ pid, name: names[pid], score: scores[pid] })).sort((a,b) => a.score - b.score);
  document.getElementById('gameover-title').textContent = `${sorted[0].name} Wins! üéâ`;
  let html = '<div class="score-table">';
  sorted.forEach((p,i) => { html += `<div class="score-row ${i===0?'winner':''}"><span>${i+1}. ${p.name}</span><span>${p.score}pts</span></div>`; });
  html += '</div>';
  document.getElementById('gameover-content').innerHTML = html;
  document.getElementById('game-over-modal').classList.add('open');
}

window.nextRound = async function() {
  if (!isHost) return;
  const gs = gameState;
  const deck = shuffle(buildDeck());
  const hands = {};
  gs.playerOrder.forEach(pid => { hands[pid] = [deck.shift(), deck.shift(), deck.shift(), deck.shift()]; });
  const discard = deck.shift();
  const newGs = { ...gs, deck, discard:[discard], hands, caboCallerId:null, lastTurns:{},
    phase:'initial-peek', drawnCard:null, round:(gs.round||1)+1, log:[] };
  delete newGs.peekReady;
  await set(ref(db, `rooms/${roomCode}/game`), newGs);
  myKnownCards.clear(); initialPeekCount=0; initialPeekDone=false; pendingAction=null;
  document.getElementById('round-modal').classList.remove('open');
};

window.closeRoundModal = function() { document.getElementById('round-modal').classList.remove('open'); };
window.playAgain = function() { location.reload(); };

// ‚îÄ‚îÄ Chat ‚îÄ‚îÄ
window.sendChat = async function() {
  const input = document.getElementById('chat-input');
  const text = input.value.trim();
  if (!text || !roomCode) return;
  input.value = '';
  await set(push(ref(db, `rooms/${roomCode}/chat`)), { id: myId, name: myName, text, ts: Date.now() });
};

// ‚îÄ‚îÄ Toast ‚îÄ‚îÄ
function showToast(msg, duration=2000) {
  const t = document.createElement('div');
  t.style.cssText = `position:fixed;bottom:55px;left:50%;transform:translateX(-50%);background:var(--surface2);border:1px solid var(--accent);color:var(--accent);padding:8px 16px;border-radius:7px;font-size:11px;z-index:999;font-family:'DM Mono',monospace;white-space:nowrap;pointer-events:none;`;
  t.textContent = msg;
  document.body.appendChild(t);
  setTimeout(() => t.remove(), duration);
}

function esc(s) { return s.replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;'); }

// ‚îÄ‚îÄ Bindings ‚îÄ‚îÄ
document.getElementById('player-name-input').addEventListener('keydown', e => { if(e.key==='Enter') setName(); });
document.getElementById('join-code-input').addEventListener('keydown', e => { if(e.key==='Enter') joinRoom(); });
document.getElementById('join-code-input').addEventListener('input', e => { e.target.value = e.target.value.toUpperCase(); });
document.getElementById('chat-input').addEventListener('keydown', e => { if(e.key==='Enter') sendChat(); });

setTimeout(() => {
  document.getElementById('loading').style.display = 'none';
  document.getElementById('lobby').style.display = 'flex';
}, 700);
</script>
</body>
</html>
