<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>CABO â€” Online Card Game</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=Playfair+Display:wght@400;700;900&family=DM+Mono:wght@300;400;500&display=swap');

  :root {
    --bg: #0a0a0f;
    --surface: #13131a;
    --surface2: #1e1e2a;
    --border: #2a2a3a;
    --accent: #c8a96e;
    --accent2: #e8c98e;
    --red: #e05555;
    --green: #55b87a;
    --blue: #5599e0;
    --purple: #9966cc;
    --text: #e8e8f0;
    --muted: #888899;
    --card-w: 64px;
    --card-h: 90px;
  }

  * { box-sizing: border-box; margin: 0; padding: 0; }

  body {
    background: var(--bg);
    color: var(--text);
    font-family: 'DM Mono', monospace;
    min-height: 100vh;
    overflow-x: hidden;
  }

  /* â”€â”€â”€ LOBBY â”€â”€â”€ */
  #lobby {
    display: flex; flex-direction: column; align-items: center; justify-content: center;
    min-height: 100vh; gap: 32px; padding: 24px;
    background: radial-gradient(ellipse at 50% 0%, #1a1428 0%, var(--bg) 70%);
  }

  .logo {
    font-family: 'Playfair Display', serif;
    font-size: clamp(56px, 10vw, 96px);
    font-weight: 900;
    letter-spacing: 0.15em;
    color: var(--accent);
    text-shadow: 0 0 60px rgba(200,169,110,0.3);
    position: relative;
  }
  .logo::after {
    content: 'CARD GAME';
    display: block;
    font-size: 0.18em;
    letter-spacing: 0.5em;
    color: var(--muted);
    text-align: center;
    font-family: 'DM Mono', monospace;
    font-weight: 300;
    margin-top: 4px;
  }

  .lobby-box {
    background: var(--surface);
    border: 1px solid var(--border);
    border-radius: 16px;
    padding: 36px;
    width: 100%;
    max-width: 440px;
    display: flex; flex-direction: column; gap: 16px;
  }

  .lobby-box h2 {
    font-family: 'Playfair Display', serif;
    font-size: 20px;
    color: var(--accent);
    margin-bottom: 4px;
  }

  label { font-size: 11px; letter-spacing: 0.1em; color: var(--muted); text-transform: uppercase; }

  input[type=text] {
    width: 100%; padding: 12px 16px;
    background: var(--surface2); border: 1px solid var(--border);
    border-radius: 8px; color: var(--text); font-family: 'DM Mono', monospace;
    font-size: 15px; outline: none; transition: border-color 0.2s;
  }
  input[type=text]:focus { border-color: var(--accent); }

  .btn {
    padding: 13px 24px; border-radius: 8px; border: none;
    font-family: 'DM Mono', monospace; font-size: 14px; font-weight: 500;
    cursor: pointer; transition: all 0.15s; letter-spacing: 0.05em;
  }
  .btn-primary { background: var(--accent); color: #0a0a0f; }
  .btn-primary:hover { background: var(--accent2); transform: translateY(-1px); }
  .btn-secondary { background: var(--surface2); color: var(--text); border: 1px solid var(--border); }
  .btn-secondary:hover { border-color: var(--accent); color: var(--accent); }
  .btn:disabled { opacity: 0.4; cursor: not-allowed; transform: none !important; }

  .divider { display: flex; align-items: center; gap: 12px; color: var(--muted); font-size: 11px; }
  .divider::before, .divider::after { content: ''; flex: 1; height: 1px; background: var(--border); }

  .room-code-display {
    background: var(--surface2); border: 1px dashed var(--accent);
    border-radius: 8px; padding: 16px; text-align: center;
  }
  .room-code-display .code {
    font-size: 32px; letter-spacing: 0.3em; color: var(--accent);
    font-family: 'Playfair Display', serif; font-weight: 700;
  }
  .room-code-display .hint { font-size: 11px; color: var(--muted); margin-top: 4px; }

  .player-list { display: flex; flex-direction: column; gap: 8px; }
  .player-item {
    display: flex; align-items: center; gap: 10px;
    padding: 10px 14px; background: var(--surface2); border-radius: 8px;
    border: 1px solid var(--border); font-size: 13px;
  }
  .player-item.me { border-color: var(--accent); }
  .player-dot { width: 8px; height: 8px; border-radius: 50%; background: var(--green); flex-shrink: 0; }
  .player-item .host-badge { margin-left: auto; font-size: 10px; color: var(--accent); letter-spacing: 0.05em; }

  /* â”€â”€â”€ GAME â”€â”€â”€ */
  #game { display: none; flex-direction: column; min-height: 100vh; }

  .game-header {
    display: flex; align-items: center; justify-content: space-between;
    padding: 12px 20px; background: var(--surface);
    border-bottom: 1px solid var(--border); flex-shrink: 0;
  }
  .game-title { font-family: 'Playfair Display', serif; font-size: 22px; color: var(--accent); }
  .turn-info { font-size: 12px; color: var(--muted); text-align: center; }
  .turn-info .active { color: var(--accent2); font-size: 14px; font-weight: 500; }

  .score-strip {
    display: flex; gap: 8px; padding: 10px 20px; background: var(--surface2);
    border-bottom: 1px solid var(--border); overflow-x: auto; flex-shrink: 0;
  }
  .score-badge {
    display: flex; flex-direction: column; align-items: center;
    padding: 6px 14px; background: var(--surface); border-radius: 8px;
    border: 1px solid var(--border); min-width: 80px; flex-shrink: 0;
    font-size: 11px; gap: 2px; transition: border-color 0.2s;
  }
  .score-badge.active-player { border-color: var(--accent); }
  .score-badge .sname { color: var(--muted); text-overflow: ellipsis; overflow: hidden; white-space: nowrap; max-width: 80px; }
  .score-badge .sval { color: var(--text); font-size: 16px; font-family: 'Playfair Display', serif; }
  .score-badge .sround { color: var(--muted); font-size: 10px; }

  .game-board {
    flex: 1; display: flex; flex-direction: column;
    gap: 16px; padding: 16px; overflow-y: auto;
  }

  .opponents-area { display: flex; flex-wrap: wrap; gap: 12px; justify-content: center; }

  .opponent-zone {
    background: var(--surface); border: 1px solid var(--border);
    border-radius: 12px; padding: 14px; min-width: 180px;
    display: flex; flex-direction: column; gap: 10px; align-items: center;
  }
  .opponent-zone.active-turn { border-color: var(--accent); box-shadow: 0 0 20px rgba(200,169,110,0.15); }
  .opponent-name { font-size: 12px; color: var(--muted); }

  /* â”€â”€â”€ CENTER â”€â”€â”€ */
  .center-area {
    display: flex; align-items: center; justify-content: center; gap: 24px; flex-wrap: wrap;
  }

  .pile-container { display: flex; flex-direction: column; align-items: center; gap: 8px; }
  .pile-label { font-size: 10px; letter-spacing: 0.15em; color: var(--muted); text-transform: uppercase; }

  /* â”€â”€â”€ CARD â”€â”€â”€ */
  .card {
    width: var(--card-w); height: var(--card-h);
    border-radius: 8px; border: 1px solid var(--border);
    cursor: pointer; transition: all 0.15s;
    display: flex; align-items: center; justify-content: center;
    position: relative; user-select: none; flex-shrink: 0;
    font-family: 'Playfair Display', serif;
  }

  .card.face-down {
    background: linear-gradient(135deg, #1e1e35 0%, #2a2a45 50%, #1e1e35 100%);
    background-image: 
      linear-gradient(135deg, #1e1e35 0%, #2a2a45 50%, #1e1e35 100%),
      repeating-linear-gradient(45deg, transparent, transparent 4px, rgba(200,169,110,0.04) 4px, rgba(200,169,110,0.04) 8px);
  }
  .card.face-down::after {
    content: 'âœ¦';
    color: var(--accent);
    opacity: 0.3;
    font-size: 22px;
  }

  .card.face-up {
    background: #f5f0e8; color: #1a1a1a;
    flex-direction: column; justify-content: space-between; padding: 5px;
  }
  .card.face-up.red-suit { color: #c0392b; }

  .card-corner { font-size: 13px; font-weight: 700; line-height: 1; }
  .card-center { font-size: 22px; }
  .card-corner.bottom { align-self: flex-end; transform: rotate(180deg); }

  .card.special { box-shadow: inset 0 0 0 2px rgba(200,169,110,0.4); }
  .card.peek-card { box-shadow: inset 0 0 0 2px rgba(85,184,122,0.5); }
  .card.spy-card { box-shadow: inset 0 0 0 2px rgba(85,153,224,0.5); }
  .card.swap-card { box-shadow: inset 0 0 0 2px rgba(153,102,204,0.5); }

  .card:hover { transform: translateY(-4px); box-shadow: 0 8px 20px rgba(0,0,0,0.4); }
  .card.selected { transform: translateY(-8px); box-shadow: 0 0 0 2px var(--accent), 0 12px 24px rgba(0,0,0,0.5); }
  .card.selectable { cursor: pointer; }
  .card.selectable:hover { border-color: var(--accent); }
  .card.not-selectable { cursor: default; }
  .card.not-selectable:hover { transform: none; box-shadow: none; }

  .deck-card {
    background: linear-gradient(135deg, #1e1e35 0%, #2a2a45 100%);
    position: relative; overflow: hidden;
  }
  .deck-card::before {
    content: attr(data-count);
    position: absolute; bottom: 6px; right: 8px;
    font-size: 10px; color: var(--accent); opacity: 0.7;
    font-family: 'DM Mono', monospace;
  }

  .discard-empty {
    width: var(--card-w); height: var(--card-h);
    border-radius: 8px; border: 2px dashed var(--border);
    display: flex; align-items: center; justify-content: center;
    color: var(--border); font-size: 20px;
  }

  /* â”€â”€â”€ MY AREA â”€â”€â”€ */
  .my-area {
    background: var(--surface); border: 1px solid var(--border);
    border-radius: 12px; padding: 16px;
    display: flex; flex-direction: column; gap: 12px; align-items: center;
  }
  .my-area.my-turn { border-color: var(--accent); }
  .my-cards { display: flex; gap: 8px; flex-wrap: wrap; justify-content: center; }

  /* â”€â”€â”€ ACTION BAR â”€â”€â”€ */
  .action-bar {
    display: flex; gap: 8px; flex-wrap: wrap; justify-content: center;
    padding: 12px 16px; background: var(--surface2);
    border-top: 1px solid var(--border); flex-shrink: 0;
  }

  .btn-action { font-size: 12px; padding: 10px 18px; }
  .btn-danger { background: rgba(224,85,85,0.15); color: var(--red); border: 1px solid rgba(224,85,85,0.3); }
  .btn-danger:hover { background: rgba(224,85,85,0.25); border-color: var(--red); }
  .btn-success { background: rgba(85,184,122,0.15); color: var(--green); border: 1px solid rgba(85,184,122,0.3); }
  .btn-success:hover { background: rgba(85,184,122,0.25); border-color: var(--green); }
  .btn-blue { background: rgba(85,153,224,0.15); color: var(--blue); border: 1px solid rgba(85,153,224,0.3); }
  .btn-blue:hover { background: rgba(85,153,224,0.25); border-color: var(--blue); }

  /* â”€â”€â”€ LOG â”€â”€â”€ */
  .log-panel {
    max-height: 80px; overflow-y: auto; padding: 0 20px;
    display: flex; flex-direction: column-reverse; gap: 4px;
    flex-shrink: 0;
  }
  .log-entry { font-size: 11px; color: var(--muted); }
  .log-entry .name { color: var(--accent); }
  .log-entry .action { color: var(--text); }

  /* â”€â”€â”€ MODAL â”€â”€â”€ */
  .modal-overlay {
    position: fixed; inset: 0; background: rgba(0,0,0,0.7);
    display: flex; align-items: center; justify-content: center;
    z-index: 100; backdrop-filter: blur(4px);
    opacity: 0; pointer-events: none; transition: opacity 0.2s;
  }
  .modal-overlay.open { opacity: 1; pointer-events: all; }

  .modal {
    background: var(--surface); border: 1px solid var(--border);
    border-radius: 16px; padding: 32px; max-width: 400px; width: 90%;
    text-align: center; display: flex; flex-direction: column; gap: 16px;
    transform: scale(0.95); transition: transform 0.2s;
  }
  .modal-overlay.open .modal { transform: scale(1); }
  .modal h2 { font-family: 'Playfair Display', serif; font-size: 26px; color: var(--accent); }
  .modal p { font-size: 13px; color: var(--muted); line-height: 1.6; }
  .modal .score-table { text-align: left; font-size: 13px; width: 100%; }
  .modal .score-row { display: flex; justify-content: space-between; padding: 6px 0; border-bottom: 1px solid var(--border); }
  .modal .score-row.winner { color: var(--green); }

  /* Peek/Spy overlay on card */
  .peek-overlay {
    position: absolute; inset: 0; background: rgba(0,0,0,0.7);
    border-radius: 8px; display: flex; align-items: center; justify-content: center;
    color: var(--accent); font-size: 11px; text-align: center; padding: 4px;
    pointer-events: none; opacity: 0; transition: opacity 0.3s;
    font-family: 'DM Mono', monospace;
  }
  .card:hover .peek-overlay.visible { opacity: 1; }

  /* Status chips */
  .status-chip {
    padding: 4px 10px; border-radius: 20px; font-size: 10px; letter-spacing: 0.05em;
    display: inline-block;
  }
  .chip-cabo { background: rgba(200,169,110,0.15); color: var(--accent); border: 1px solid var(--accent); }
  .chip-last { background: rgba(224,85,85,0.15); color: var(--red); border: 1px solid var(--red); }

  .help-text { font-size: 11px; color: var(--muted); text-align: center; min-height: 28px; padding: 0 8px; }

  /* Drawn card area */
  .drawn-area {
    display: flex; flex-direction: column; align-items: center; gap: 6px;
    padding: 12px; background: var(--surface2); border-radius: 10px;
    border: 1px dashed var(--border);
  }
  .drawn-area-label { font-size: 10px; color: var(--muted); letter-spacing: 0.1em; text-transform: uppercase; }

  @keyframes pulse {
    0%, 100% { opacity: 1; }
    50% { opacity: 0.5; }
  }
  .pulsing { animation: pulse 1.5s ease-in-out infinite; }

  @keyframes slideIn {
    from { transform: translateY(20px); opacity: 0; }
    to { transform: translateY(0); opacity: 1; }
  }
  .slide-in { animation: slideIn 0.3s ease forwards; }

  /* Firebase loading */
  .loading-overlay {
    position: fixed; inset: 0; background: var(--bg);
    display: flex; flex-direction: column; align-items: center; justify-content: center;
    z-index: 200; gap: 16px;
  }
  .spinner {
    width: 40px; height: 40px; border: 3px solid var(--border);
    border-top-color: var(--accent); border-radius: 50%;
    animation: spin 0.8s linear infinite;
  }
  @keyframes spin { to { transform: rotate(360deg); } }
</style>
</head>
<body>

<!-- Loading -->
<div class="loading-overlay" id="loading">
  <div style="font-family:'Playfair Display',serif;font-size:40px;color:var(--accent)">CABO</div>
  <div class="spinner"></div>
  <div style="font-size:12px;color:var(--muted)">Connecting...</div>
</div>

<!-- LOBBY -->
<div id="lobby" style="display:none">
  <div class="logo">CABO</div>

  <div class="lobby-box" id="enter-name-box">
    <h2>Welcome</h2>
    <div>
      <label>Your Name</label>
      <input type="text" id="player-name-input" placeholder="Enter your name..." maxlength="20" />
    </div>
    <button class="btn btn-primary" onclick="setName()">Continue â†’</button>
  </div>

  <div class="lobby-box" id="lobby-main" style="display:none">
    <h2>Play Cabo</h2>
    <button class="btn btn-primary" onclick="createRoom()">ğŸ² Create New Room</button>
    <div class="divider">or</div>
    <div>
      <label>Room Code</label>
      <input type="text" id="join-code-input" placeholder="Enter 4-letter code..." maxlength="4" 
        style="text-transform:uppercase;letter-spacing:0.2em;font-size:18px" />
    </div>
    <button class="btn btn-secondary" onclick="joinRoom()">Join Room â†’</button>
  </div>

  <div class="lobby-box" id="waiting-room" style="display:none">
    <h2>Room Ready</h2>
    <div class="room-code-display">
      <div class="code" id="display-room-code">ABCD</div>
      <div class="hint">Share this code with friends</div>
    </div>
    <div>
      <label style="margin-bottom:8px;display:block">Players (<span id="player-count">1</span>/6)</label>
      <div class="player-list" id="player-list"></div>
    </div>
    <button class="btn btn-primary" id="start-btn" onclick="startGame()" disabled>
      Start Game (need 2+)
    </button>
    <button class="btn btn-secondary" onclick="leaveRoom()">â† Leave</button>
  </div>
</div>

<!-- GAME -->
<div id="game">
  <div class="game-header">
    <div class="game-title">CABO</div>
    <div class="turn-info">
      <div id="turn-label" class="pulsing">Loading...</div>
      <div id="round-label" style="margin-top:2px;font-size:11px;color:var(--muted)">Round 1</div>
    </div>
    <div id="cabo-status"></div>
  </div>

  <div class="score-strip" id="score-strip"></div>

  <div class="game-board">
    <div class="opponents-area" id="opponents-area"></div>

    <div class="center-area">
      <div class="pile-container">
        <div class="pile-label">Draw Pile</div>
        <div class="card deck-card face-down" id="deck-pile" data-count="" onclick="drawFromDeck()">
          <span style="color:var(--accent);opacity:0.3;font-size:22px">âœ¦</span>
        </div>
      </div>

      <div id="drawn-card-area" style="display:none">
        <div class="drawn-area">
          <div class="drawn-area-label">Drawn Card</div>
          <div class="card face-up" id="drawn-card-display" style="cursor:default"></div>
          <div style="display:flex;gap:6px;margin-top:4px">
            <button class="btn btn-secondary btn-action" onclick="discardDrawnCard()">Discard</button>
            <button class="btn btn-success btn-action" id="use-power-btn" onclick="usePower()" style="display:none">Use Power</button>
          </div>
        </div>
      </div>

      <div class="pile-container">
        <div class="pile-label">Discard Pile</div>
        <div id="discard-pile-display">
          <div class="discard-empty">+</div>
        </div>
      </div>
    </div>

    <div class="help-text" id="help-text">Waiting...</div>

    <div class="my-area" id="my-area">
      <div style="font-size:11px;color:var(--muted)" id="my-name-label">You</div>
      <div class="my-cards" id="my-cards"></div>
    </div>

    <div class="log-panel" id="log-panel"></div>
  </div>

  <div class="action-bar" id="action-bar">
    <button class="btn btn-action btn-danger" id="cabo-btn" onclick="callCabo()">ğŸ“£ Call CABO</button>
  </div>
</div>

<!-- Round End Modal -->
<div class="modal-overlay" id="round-modal">
  <div class="modal">
    <h2>Round Over!</h2>
    <div id="round-modal-content"></div>
    <button class="btn btn-primary" id="next-round-btn" onclick="nextRound()" style="display:none">Next Round â†’</button>
    <button class="btn btn-secondary" onclick="closeRoundModal()">Continue</button>
  </div>
</div>

<!-- Game End Modal -->
<div class="modal-overlay" id="game-over-modal">
  <div class="modal">
    <h2 id="gameover-title">Game Over!</h2>
    <div id="gameover-content"></div>
    <button class="btn btn-primary" onclick="playAgain()">Play Again</button>
  </div>
</div>

<!-- Peek Modal -->
<div class="modal-overlay" id="peek-modal">
  <div class="modal">
    <h2>ğŸ‘ Peek</h2>
    <p id="peek-msg">Choose one of your cards to peek at.</p>
    <button class="btn btn-secondary" onclick="cancelPeek()">Cancel</button>
  </div>
</div>

<!-- Spy Modal -->
<div class="modal-overlay" id="spy-modal">
  <div class="modal">
    <h2>ğŸ” Spy</h2>
    <p id="spy-msg">Choose an opponent's card to peek at.</p>
    <div id="spy-result" style="margin:8px 0"></div>
    <button class="btn btn-secondary" onclick="cancelSpy()">Cancel</button>
  </div>
</div>

<!-- Swap Modal -->
<div class="modal-overlay" id="swap-modal">
  <div class="modal">
    <h2>ğŸ”„ Swap</h2>
    <p id="swap-msg">First select one of YOUR cards, then an OPPONENT's card.</p>
    <div id="swap-my-display" style="margin-top:8px"></div>
    <button class="btn btn-secondary" onclick="cancelSwap()">Cancel</button>
  </div>
</div>

<!-- Firebase SDK -->
<script type="module">
import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-app.js";
import { getDatabase, ref, set, get, update, onValue, push, remove, off }
  from "https://www.gstatic.com/firebasejs/10.12.2/firebase-database.js";

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  FIREBASE CONFIG â€” replace with your own!
//  (free plan, no credit card needed)
//  Steps: go to console.firebase.google.com
//  Create project â†’ Realtime Database â†’ Start in test mode
//  Copy config here
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const firebaseConfig = {
  apiKey: "REPLACE_WITH_YOUR_API_KEY",
  authDomain: "REPLACE_WITH_YOUR_PROJECT.firebaseapp.com",
  databaseURL: "https://REPLACE_WITH_YOUR_PROJECT-default-rtdb.firebaseio.com",
  projectId: "REPLACE_WITH_YOUR_PROJECT",
  storageBucket: "REPLACE_WITH_YOUR_PROJECT.appspot.com",
  messagingSenderId: "REPLACE",
  appId: "REPLACE"
};

const app = initializeApp(firebaseConfig);
const db = getDatabase(app);

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  GAME STATE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
let myId = null;       // Firebase push key
let myName = '';
let roomCode = null;
let roomRef = null;
let gameState = null;
let isHost = false;
let listeners = [];

// Peek/Spy/Swap state
let pendingAction = null; // { type, drawnCard }
let swapMyCard = null;    // { pos }

// For initial peek at start
let initialPeekCount = 0;
let initialPeekDone = false;

const SUITS = ['â™ ','â™¥','â™¦','â™£'];
const SUIT_RED = new Set(['â™¥','â™¦']);

function buildDeck() {
  let deck = [];
  for (let v = 0; v <= 13; v++) {
    for (let s of SUITS) {
      deck.push({ value: v, suit: s });
    }
  }
  // jokers (value 0)
  deck.push({ value: 0, suit: 'â˜…' });
  deck.push({ value: 0, suit: 'â˜…' });
  return deck;
}

function shuffle(arr) {
  const a = [...arr];
  for (let i = a.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [a[i], a[j]] = [a[j], a[i]];
  }
  return a;
}

function cardPower(card) {
  if (!card) return null;
  if (card.value === 7 || card.value === 8) return 'peek';
  if (card.value === 9 || card.value === 10) return 'spy';
  if (card.value === 11 || card.value === 12) return 'swap';
  return null;
}

function cardDisplay(card) {
  if (!card) return '';
  const v = card.value;
  let label = String(v);
  if (v === 0) label = card.suit === 'â˜…' ? 'â˜…' : '0';
  if (v === 11) label = 'J';
  if (v === 12) label = 'Q';
  if (v === 13) label = 'K';
  return { label, suit: card.suit, isRed: SUIT_RED.has(card.suit) };
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  CARD RENDERING
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function makeCardEl(card, opts = {}) {
  const el = document.createElement('div');
  el.className = 'card';
  if (!card || opts.faceDown) {
    el.classList.add('face-down');
    return el;
  }
  el.classList.add('face-up');
  const d = cardDisplay(card);
  if (d.isRed) el.classList.add('red-suit');
  const power = cardPower(card);
  if (power === 'peek') el.classList.add('peek-card');
  if (power === 'spy') el.classList.add('spy-card');
  if (power === 'swap') el.classList.add('swap-card');

  el.innerHTML = `
    <span class="card-corner">${d.label}</span>
    <span class="card-center">${d.suit}</span>
    <span class="card-corner bottom">${d.label}</span>
  `;
  return el;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  LOBBY
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function showScreen(id) {
  document.getElementById('loading').style.display = 'none';
  document.getElementById('lobby').style.display = id === 'lobby' ? 'flex' : 'none';
  document.getElementById('game').style.display = id === 'game' ? 'flex' : 'none';
}

window.setName = function() {
  const n = document.getElementById('player-name-input').value.trim();
  if (!n) return;
  myName = n;
  document.getElementById('enter-name-box').style.display = 'none';
  document.getElementById('lobby-main').style.display = 'flex';
};

window.createRoom = async function() {
  const code = Array.from({length:4}, () => 'ABCDEFGHJKLMNPQRSTUVWXYZ'[Math.floor(Math.random()*23)]).join('');
  roomCode = code;
  isHost = true;
  await joinRoomWithCode(code);
};

window.joinRoom = async function() {
  const code = document.getElementById('join-code-input').value.trim().toUpperCase();
  if (code.length !== 4) return alert('Enter a 4-letter room code');
  const snap = await get(ref(db, `rooms/${code}`));
  if (!snap.exists()) return alert('Room not found');
  const room = snap.val();
  if (room.state !== 'lobby') return alert('Game already started');
  roomCode = code;
  isHost = false;
  await joinRoomWithCode(code);
};

async function joinRoomWithCode(code) {
  roomRef = ref(db, `rooms/${code}`);
  const playerRef = push(ref(db, `rooms/${code}/players`));
  myId = playerRef.key;

  const snap = await get(ref(db, `rooms/${code}/players`));
  const existing = snap.val() || {};
  const count = Object.keys(existing).length;

  await set(playerRef, { name: myName, id: myId, score: 0 });

  if (count === 0) {
    // first player = host, set up room
    await set(ref(db, `rooms/${code}/state`), 'lobby');
    await set(ref(db, `rooms/${code}/host`), myId);
  }

  document.getElementById('display-room-code').textContent = code;
  document.getElementById('lobby-main').style.display = 'none';
  document.getElementById('waiting-room').style.display = 'flex';

  listenLobby();
}

function listenLobby() {
  const pr = ref(db, `rooms/${roomCode}/players`);
  const unsub = onValue(pr, snap => {
    const players = snap.val() || {};
    const arr = Object.values(players);
    document.getElementById('player-count').textContent = arr.length;
    const list = document.getElementById('player-list');
    list.innerHTML = '';
    arr.forEach(p => {
      const div = document.createElement('div');
      div.className = 'player-item' + (p.id === myId ? ' me' : '');
      div.innerHTML = `<div class="player-dot"></div><span>${p.name}</span>${p.id === arr[0]?.id ? '<span class="host-badge">HOST</span>' : ''}`;
      list.appendChild(div);
    });
    const startBtn = document.getElementById('start-btn');
    startBtn.disabled = arr.length < 2 || arr[0]?.id !== myId;
    startBtn.textContent = arr.length < 2 ? 'Start Game (need 2+)' : `Start Game (${arr.length} players)`;
  });
  listeners.push({ ref: pr, unsub });

  const sr = ref(db, `rooms/${roomCode}/state`);
  const unsub2 = onValue(sr, snap => {
    if (snap.val() === 'playing') {
      document.getElementById('waiting-room').style.display = 'none';
      off(pr);
      off(sr);
      initGame();
    }
  });
}

window.leaveRoom = function() {
  if (roomCode && myId) {
    remove(ref(db, `rooms/${roomCode}/players/${myId}`));
  }
  location.reload();
};

window.startGame = async function() {
  if (!isHost) return;
  const snap = await get(ref(db, `rooms/${roomCode}/players`));
  const playersObj = snap.val();
  const playerArr = Object.values(playersObj);

  const deck = shuffle(buildDeck());
  const hands = {};
  playerArr.forEach(p => {
    hands[p.id] = [deck.shift(), deck.shift(), deck.shift(), deck.shift()];
  });

  const discard = deck.shift();
  const state = {
    deck,
    discard: [discard],
    hands,
    playerOrder: playerArr.map(p => p.id),
    playerNames: Object.fromEntries(playerArr.map(p => [p.id, p.name])),
    scores: Object.fromEntries(playerArr.map(p => [p.id, 0])),
    currentTurn: playerArr[0].id,
    caboCallerId: null,
    lastTurns: {},      // pid -> turns remaining after cabo
    phase: 'initial-peek',  // initial-peek â†’ play â†’ round-end
    drawnCard: null,
    round: 1,
    log: []
  };

  await set(roomRef, { state: 'playing', players: playersObj, host: myId, game: state });
};

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  GAME
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function initGame() {
  showScreen('game');
  const gr = ref(db, `rooms/${roomCode}/game`);
  const unsub = onValue(gr, snap => {
    if (!snap.exists()) return;
    gameState = snap.val();
    // Firebase stores arrays as objects sometimes
    if (gameState.deck && !Array.isArray(gameState.deck)) gameState.deck = Object.values(gameState.deck);
    gameState.playerOrder.forEach(pid => {
      if (gameState.hands[pid] && !Array.isArray(gameState.hands[pid]))
        gameState.hands[pid] = Object.values(gameState.hands[pid]);
      if (gameState.discard && !Array.isArray(gameState.discard))
        gameState.discard = Object.values(gameState.discard);
    });
    renderGame();
  });
}

function isMyTurn() { return gameState && gameState.currentTurn === myId; }

function renderGame() {
  if (!gameState) return;
  const gs = gameState;

  // Header
  const myTurn = isMyTurn();
  const currentName = gs.playerNames[gs.currentTurn] || '?';
  document.getElementById('turn-label').textContent = myTurn ? 'âœ¨ Your Turn' : `${currentName}'s Turn`;
  document.getElementById('turn-label').style.color = myTurn ? 'var(--accent2)' : 'var(--text)';
  document.getElementById('round-label').textContent = `Round ${gs.round || 1}`;

  if (gs.caboCallerId) {
    const callerName = gs.playerNames[gs.caboCallerId];
    document.getElementById('cabo-status').innerHTML = `<span class="status-chip chip-cabo">CABO called by ${callerName}</span>`;
  } else {
    document.getElementById('cabo-status').innerHTML = '';
  }

  // Scores
  const strip = document.getElementById('score-strip');
  strip.innerHTML = '';
  gs.playerOrder.forEach(pid => {
    const div = document.createElement('div');
    div.className = 'score-badge' + (pid === gs.currentTurn ? ' active-player' : '');
    const roundScore = gs.scores?.[pid] ?? 0;
    div.innerHTML = `
      <span class="sname">${gs.playerNames[pid]}${pid === myId ? ' (you)' : ''}</span>
      <span class="sval">${roundScore}</span>
      <span class="sround">total</span>
    `;
    strip.appendChild(div);
  });

  // Opponents
  const oppArea = document.getElementById('opponents-area');
  oppArea.innerHTML = '';
  gs.playerOrder.filter(pid => pid !== myId).forEach(pid => {
    const zone = document.createElement('div');
    zone.className = 'opponent-zone' + (pid === gs.currentTurn ? ' active-turn' : '');
    const hand = gs.hands[pid] || [];
    const cardsHtml = hand.map((c, i) => {
      const el = makeCardEl(c, { faceDown: true });
      el.classList.add('not-selectable');
      return el.outerHTML;
    }).join('');

    let swapBtnHtml = '';
    if (pendingAction?.type === 'swap' && swapMyCard !== null && isMyTurn()) {
      swapBtnHtml = hand.map((c, i) => 
        `<button class="btn btn-purple btn-action" style="background:rgba(153,102,204,0.15);color:var(--purple);border:1px solid var(--purple);font-size:11px;padding:6px 10px;margin:2px" onclick="swapSelectOpponent('${pid}',${i})">Card ${i+1}</button>`
      ).join('');
    }

    let spyBtnHtml = '';
    if (pendingAction?.type === 'spy' && isMyTurn()) {
      spyBtnHtml = hand.map((c, i) =>
        `<button class="btn btn-blue btn-action" style="font-size:11px;padding:6px 10px;margin:2px" onclick="spyCard('${pid}',${i})">Spy Card ${i+1}</button>`
      ).join('');
    }

    zone.innerHTML = `
      <div class="opponent-name">${gs.playerNames[pid]}</div>
      <div style="display:flex;gap:6px;flex-wrap:wrap;justify-content:center">${cardsHtml}</div>
      ${swapBtnHtml}
      ${spyBtnHtml}
    `;
    oppArea.appendChild(zone);
  });

  // Center piles
  const deck = gs.deck || [];
  const deckEl = document.getElementById('deck-pile');
  deckEl.dataset.count = deck.length;
  deckEl.style.opacity = deck.length === 0 ? '0.3' : '1';
  deckEl.style.cursor = deck.length === 0 || !myTurn || gs.phase !== 'play' || gs.drawnCard ? 'default' : 'pointer';

  const discardArr = gs.discard || [];
  const topDiscard = discardArr[discardArr.length - 1] || null;
  const discardDisplay = document.getElementById('discard-pile-display');
  if (topDiscard) {
    const el = makeCardEl(topDiscard);
    el.classList.add('not-selectable');
    discardDisplay.innerHTML = '';
    discardDisplay.appendChild(el);
  } else {
    discardDisplay.innerHTML = '<div class="discard-empty">+</div>';
  }

  // Drawn card
  const drawnArea = document.getElementById('drawn-card-area');
  if (gs.drawnCard && myTurn) {
    drawnArea.style.display = 'block';
    const dEl = makeCardEl(gs.drawnCard);
    dEl.style.cursor = 'default';
    const dDisplay = document.getElementById('drawn-card-display');
    dDisplay.innerHTML = '';
    const d = cardDisplay(gs.drawnCard);
    dDisplay.className = 'card face-up' + (d.isRed ? ' red-suit' : '');
    dDisplay.innerHTML = `
      <span class="card-corner">${d.label}</span>
      <span class="card-center">${d.suit}</span>
      <span class="card-corner bottom">${d.label}</span>
    `;
    const power = cardPower(gs.drawnCard);
    const powerBtn = document.getElementById('use-power-btn');
    if (power) {
      powerBtn.style.display = 'block';
      powerBtn.textContent = power === 'peek' ? 'ğŸ‘ Peek' : power === 'spy' ? 'ğŸ” Spy' : 'ğŸ”„ Swap';
    } else {
      powerBtn.style.display = 'none';
    }
  } else {
    drawnArea.style.display = 'none';
  }

  // My cards
  const myHand = gs.hands[myId] || [];
  const myCardsEl = document.getElementById('my-cards');
  myCardsEl.innerHTML = '';
  document.getElementById('my-name-label').textContent = myName + ' (you)';
  document.getElementById('my-area').className = 'my-area' + (myTurn ? ' my-turn' : '');

  myHand.forEach((card, i) => {
    const known = myKnownCards.has(i);
    let el;
    if (known) {
      el = makeCardEl(card); // face up, I know it
    } else {
      el = makeCardEl(card, { faceDown: true });
    }

    // Handle click actions
    if (gs.phase === 'initial-peek') {
      if (!initialPeekDone) {
        el.classList.add('selectable');
        el.onclick = () => doInitialPeek(i, card);
      } else {
        el.classList.add('not-selectable');
      }
    } else if (gs.phase === 'play' && myTurn) {
      if (gs.drawnCard && !pendingAction) {
        // Swap drawn with my card
        el.classList.add('selectable');
        el.title = 'Swap drawn card with this card';
        el.onclick = () => swapWithMyCard(i);
      } else if (pendingAction?.type === 'peek') {
        el.classList.add('selectable');
        el.onclick = () => peekMyCard(i, card);
      } else if (pendingAction?.type === 'swap' && swapMyCard === null) {
        el.classList.add('selectable');
        el.onclick = () => swapSelectMine(i);
      } else if (pendingAction?.type === 'swap' && swapMyCard !== null && i === swapMyCard) {
        el.classList.add('selected');
      } else {
        el.classList.add('not-selectable');
      }
    } else {
      el.classList.add('not-selectable');
    }

    myCardsEl.appendChild(el);
  });

  // Help text
  const helpEl = document.getElementById('help-text');
  if (gs.phase === 'initial-peek') {
    helpEl.textContent = `Peek at any 2 of your cards to memorize them (${2 - initialPeekCount} remaining)`;
  } else if (!myTurn) {
    helpEl.textContent = `Waiting for ${currentName}...`;
  } else if (gs.drawnCard && !pendingAction) {
    helpEl.textContent = 'â† Click Discard to discard, or click one of your cards to swap it';
  } else if (pendingAction?.type === 'peek') {
    helpEl.textContent = 'Click one of your cards to peek at it';
  } else if (pendingAction?.type === 'spy') {
    helpEl.textContent = 'Click an opponent\'s card button to spy on it';
  } else if (pendingAction?.type === 'swap' && swapMyCard === null) {
    helpEl.textContent = 'Select one of YOUR cards to swap...';
  } else if (pendingAction?.type === 'swap' && swapMyCard !== null) {
    helpEl.textContent = 'Now click an opponent\'s card to complete the swap';
  } else if (!gs.drawnCard) {
    helpEl.textContent = 'Draw a card from the deck, or call CABO if you think you have the lowest hand!';
  }

  // Cabo button
  const caboBtn = document.getElementById('cabo-btn');
  caboBtn.disabled = !myTurn || !!gs.caboCallerId || gs.phase !== 'play' || !!gs.drawnCard;

  // Log
  const logPanel = document.getElementById('log-panel');
  logPanel.innerHTML = '';
  const logs = gs.log || [];
  logs.slice(-8).reverse().forEach(entry => {
    const div = document.createElement('div');
    div.className = 'log-entry slide-in';
    div.innerHTML = entry;
    logPanel.appendChild(div);
  });

  // Round end
  if (gs.phase === 'round-end') {
    showRoundEnd();
  }
}

// â”€â”€ Tracked known cards (my peek memory) â”€â”€
const myKnownCards = new Set();

// â”€â”€ Initial Peek â”€â”€
function doInitialPeek(pos, card) {
  if (initialPeekCount >= 2 || initialPeekDone) return;
  initialPeekCount++;
  myKnownCards.add(pos);
  if (initialPeekCount >= 2) {
    initialPeekDone = true;
    // Mark myself ready
    update(ref(db, `rooms/${roomCode}/game/peekReady`), { [myId]: true });
    // Check if all players peeked
    setTimeout(async () => {
      const snap = await get(ref(db, `rooms/${roomCode}/game/peekReady`));
      const ready = snap.val() || {};
      const gs = gameState;
      const allReady = gs.playerOrder.every(pid => ready[pid]);
      if (allReady || isHost) {
        await update(ref(db, `rooms/${roomCode}/game`), { phase: 'play' });
      }
    }, 500);
    // Force move to play if host after 3s
    if (isHost) {
      setTimeout(async () => {
        const snap = await get(ref(db, `rooms/${roomCode}/game/phase`));
        if (snap.val() === 'initial-peek') {
          await update(ref(db, `rooms/${roomCode}/game`), { phase: 'play' });
        }
      }, 5000);
    }
  }
  renderGame();
}

// â”€â”€ Draw from Deck â”€â”€
window.drawFromDeck = async function() {
  if (!isMyTurn() || gameState.phase !== 'play' || gameState.drawnCard) return;
  const gs = gameState;
  if (!gs.deck || gs.deck.length === 0) return;
  const deck = [...gs.deck];
  const drawn = deck.shift();
  await update(ref(db, `rooms/${roomCode}/game`), {
    deck,
    drawnCard: drawn,
    log: addLog(gs.log, `<span class="name">${myName}</span> <span class="action">drew a card</span>`)
  });
};

// â”€â”€ Discard Drawn Card â”€â”€
window.discardDrawnCard = async function() {
  if (!isMyTurn() || !gameState.drawnCard) return;
  const gs = gameState;
  const discard = [...(gs.discard || []), gs.drawnCard];
  const power = cardPower(gs.drawnCard);
  const d = cardDisplay(gs.drawnCard);

  // Clear pending power actions if just discarding
  pendingAction = null;
  swapMyCard = null;

  const updates = {
    drawnCard: null,
    discard,
    log: addLog(gs.log, `<span class="name">${myName}</span> <span class="action">discarded ${d.label}${d.suit}</span>`)
  };

  // If discarding a power card, the power is NOT used (discard without using power)
  // End turn
  Object.assign(updates, nextTurnUpdates(gs));

  await update(ref(db, `rooms/${roomCode}/game`), updates);
};

// â”€â”€ Use Power â”€â”€
window.usePower = function() {
  if (!isMyTurn() || !gameState.drawnCard) return;
  const power = cardPower(gameState.drawnCard);
  if (!power) return;
  pendingAction = { type: power, drawnCard: gameState.drawnCard };
  renderGame();
};

// â”€â”€ Peek â”€â”€
window.peekMyCard = async function(pos, card) {
  if (pendingAction?.type !== 'peek') return;
  myKnownCards.add(pos);
  const gs = gameState;
  const d = cardDisplay(card);
  const discard = [...(gs.discard || []), pendingAction.drawnCard];
  const pdCard = cardDisplay(pendingAction.drawnCard);

  pendingAction = null;
  const updates = {
    drawnCard: null,
    discard,
    log: addLog(gs.log, `<span class="name">${myName}</span> <span class="action">used Peek (${pdCard.label}${pdCard.suit})</span>`)
  };
  Object.assign(updates, nextTurnUpdates(gs));
  await update(ref(db, `rooms/${roomCode}/game`), updates);

  // Show peek result
  const d2 = cardDisplay(card);
  showToast(`Card ${pos+1} is: ${d2.label}${d2.suit} (${card.value}pts)`, 2500);
};

window.cancelPeek = function() {
  pendingAction = null;
  renderGame();
};

// â”€â”€ Spy â”€â”€
window.spyCard = async function(opponentId, cardPos) {
  if (pendingAction?.type !== 'spy') return;
  const gs = gameState;
  const card = gs.hands[opponentId][cardPos];
  const opName = gs.playerNames[opponentId];
  const d = cardDisplay(card);
  const discard = [...(gs.discard || []), pendingAction.drawnCard];
  const pdCard = cardDisplay(pendingAction.drawnCard);

  pendingAction = null;
  const updates = {
    drawnCard: null,
    discard,
    log: addLog(gs.log, `<span class="name">${myName}</span> <span class="action">used Spy (${pdCard.label}${pdCard.suit})</span>`)
  };
  Object.assign(updates, nextTurnUpdates(gs));
  await update(ref(db, `rooms/${roomCode}/game`), updates);
  showToast(`${opName}'s Card ${cardPos+1}: ${d.label}${d.suit} (${card.value}pts)`, 2500);
};

window.cancelSpy = function() {
  pendingAction = null;
  renderGame();
};

// â”€â”€ Swap â”€â”€
window.swapSelectMine = function(pos) {
  swapMyCard = pos;
  renderGame();
};

window.swapSelectOpponent = async function(opponentId, cardPos) {
  if (pendingAction?.type !== 'swap' || swapMyCard === null) return;
  const gs = gameState;
  const myHand = [...gs.hands[myId]];
  const oppHand = [...gs.hands[opponentId]];
  const temp = myHand[swapMyCard];
  myHand[swapMyCard] = oppHand[cardPos];
  oppHand[cardPos] = temp;

  // Update known cards
  myKnownCards.delete(swapMyCard); // now unknown (it was opponent's)
  const opName = gs.playerNames[opponentId];
  const discard = [...(gs.discard || []), pendingAction.drawnCard];
  const pdCard = cardDisplay(pendingAction.drawnCard);

  pendingAction = null;
  swapMyCard = null;

  const updates = {
    drawnCard: null,
    discard,
    [`hands/${myId}`]: myHand,
    [`hands/${opponentId}`]: oppHand,
    log: addLog(gs.log, `<span class="name">${myName}</span> <span class="action">swapped a card with ${opName}</span>`)
  };
  Object.assign(updates, nextTurnUpdates(gs));
  await update(ref(db, `rooms/${roomCode}/game`), updates);
};

window.cancelSwap = function() {
  pendingAction = null;
  swapMyCard = null;
  renderGame();
};

// â”€â”€ Swap drawn with my card â”€â”€
window.swapWithMyCard = async function(pos) {
  if (!isMyTurn() || !gameState.drawnCard) return;
  const gs = gameState;
  const myHand = [...gs.hands[myId]];
  const oldCard = myHand[pos];
  myHand[pos] = gs.drawnCard;
  const discard = [...(gs.discard || []), oldCard];
  const d = cardDisplay(gs.drawnCard);
  const od = cardDisplay(oldCard);

  myKnownCards.add(pos); // now I know this card
  myKnownCards.delete(pos); // it's the drawn card I just saw

  const updates = {
    drawnCard: null,
    discard,
    [`hands/${myId}`]: myHand,
    log: addLog(gs.log, `<span class="name">${myName}</span> <span class="action">swapped ${d.label}${d.suit} into their hand</span>`)
  };
  Object.assign(updates, nextTurnUpdates(gs));
  await update(ref(db, `rooms/${roomCode}/game`), updates);
};

// â”€â”€ Call CABO â”€â”€
window.callCabo = async function() {
  if (!isMyTurn() || gameState.caboCallerId || gameState.phase !== 'play') return;
  const gs = gameState;
  // Everyone else gets 1 more turn
  const lastTurns = {};
  gs.playerOrder.forEach((pid, idx) => {
    if (pid !== myId) lastTurns[pid] = 1;
  });

  const updates = {
    caboCallerId: myId,
    lastTurns,
    log: addLog(gs.log, `<span class="name">${myName}</span> <span class="action" style="color:var(--accent)">called CABO! ğŸ¯</span>`)
  };
  Object.assign(updates, nextTurnUpdates(gs));
  await update(ref(db, `rooms/${roomCode}/game`), updates);
};

// â”€â”€ Advance Turn â”€â”€
function nextTurnUpdates(gs) {
  const order = gs.playerOrder;
  const curIdx = order.indexOf(gs.currentTurn);
  let nextIdx = (curIdx + 1) % order.length;
  const nextPid = order[nextIdx];

  // Check if cabo was called and we've gone around
  if (gs.caboCallerId) {
    const lastTurns = { ...(gs.lastTurns || {}) };
    // Mark current player's last turn done
    if (lastTurns[gs.currentTurn] !== undefined) {
      lastTurns[gs.currentTurn]--;
    }
    // Check if all non-caller last turns done
    const nonCallerIds = order.filter(pid => pid !== gs.caboCallerId);
    const allDone = nonCallerIds.every(pid => 
      lastTurns[pid] === undefined || lastTurns[pid] <= 0
    );
    if (allDone) {
      return { currentTurn: nextPid, phase: 'round-end', lastTurns };
    }
    return { currentTurn: nextPid, lastTurns };
  }

  return { currentTurn: nextPid };
}

function addLog(existing, entry) {
  const logs = [...(existing || [])];
  logs.push(entry);
  if (logs.length > 20) logs.shift();
  return logs;
}

// â”€â”€ Round End â”€â”€
function showRoundEnd() {
  const gs = gameState;
  const results = gs.playerOrder.map(pid => {
    const hand = gs.hands[pid] || [];
    const total = hand.reduce((s, c) => s + (c?.value || 0), 0);
    return { pid, name: gs.playerNames[pid], hand, total };
  });

  results.sort((a, b) => a.total - b.total);
  const lowestScore = results[0].total;
  const caboCallerId = gs.caboCallerId;

  const scoringResults = results.map(r => {
    let roundPoints = r.total;
    if (r.pid === caboCallerId) {
      if (r.total <= lowestScore && r.total === results[0].total) {
        roundPoints = 0; // Cabo caller wins - 0 points
      } else {
        roundPoints = r.total + 10; // Penalty
      }
    }
    return { ...r, roundPoints };
  });

  const newScores = { ...(gs.scores || {}) };
  scoringResults.forEach(r => {
    newScores[r.pid] = (newScores[r.pid] || 0) + r.roundPoints;
  });

  // Check winner (first to 100 loses, or play N rounds)
  const gameOver = Object.values(newScores).some(s => s >= 100);

  let html = '<div class="score-table">';
  scoringResults.forEach(r => {
    const d0 = cardDisplay(r.hand[0]);
    const d1 = cardDisplay(r.hand[1]);
    const d2 = cardDisplay(r.hand[2]);
    const d3 = cardDisplay(r.hand[3]);
    const isCabo = r.pid === caboCallerId;
    html += `<div class="score-row ${r.roundPoints === 0 ? 'winner' : ''}">
      <span>${r.name}${isCabo ? ' ğŸ“£' : ''}</span>
      <span>${r.roundPoints > 0 ? '+' : ''}${r.roundPoints} pts (total: ${newScores[r.pid]})</span>
    </div>`;
  });
  html += '</div>';

  document.getElementById('round-modal-content').innerHTML = html;
  document.getElementById('next-round-btn').style.display = isHost ? 'block' : 'none';
  document.getElementById('round-modal').classList.add('open');

  if (isHost && !gameOver) {
    // Store new scores
    update(ref(db, `rooms/${roomCode}/game`), { scores: newScores });
  }
  if (isHost && gameOver) {
    update(ref(db, `rooms/${roomCode}/game`), { scores: newScores, phase: 'game-over' });
    showGameOver(newScores, gs.playerNames, gs.playerOrder);
  }
}

function showGameOver(scores, names, order) {
  document.getElementById('round-modal').classList.remove('open');
  const sorted = order.map(pid => ({ pid, name: names[pid], score: scores[pid] }))
    .sort((a, b) => a.score - b.score);
  const winner = sorted[0];

  document.getElementById('gameover-title').textContent = `${winner.name} Wins! ğŸ‰`;
  let html = '<div class="score-table">';
  sorted.forEach((p, i) => {
    html += `<div class="score-row ${i === 0 ? 'winner' : ''}">
      <span>${i+1}. ${p.name}</span><span>${p.score} pts</span>
    </div>`;
  });
  html += '</div>';
  document.getElementById('gameover-content').innerHTML = html;
  document.getElementById('game-over-modal').classList.add('open');
}

window.nextRound = async function() {
  if (!isHost) return;
  const gs = gameState;
  const players = gs.playerOrder;
  const deck = shuffle(buildDeck());
  const hands = {};
  players.forEach(pid => {
    hands[pid] = [deck.shift(), deck.shift(), deck.shift(), deck.shift()];
  });
  const discard = deck.shift();
  const newGs = {
    ...gs,
    deck,
    discard: [discard],
    hands,
    caboCallerId: null,
    lastTurns: {},
    phase: 'initial-peek',
    drawnCard: null,
    round: (gs.round || 1) + 1,
    log: []
  };
  delete newGs.peekReady;
  await set(ref(db, `rooms/${roomCode}/game`), newGs);

  // Reset local state
  myKnownCards.clear();
  initialPeekCount = 0;
  initialPeekDone = false;
  pendingAction = null;
  swapMyCard = null;
  document.getElementById('round-modal').classList.remove('open');
};

window.closeRoundModal = function() {
  document.getElementById('round-modal').classList.remove('open');
};

window.playAgain = function() {
  location.reload();
};

// â”€â”€ Toast â”€â”€
function showToast(msg, duration = 2000) {
  const t = document.createElement('div');
  t.style.cssText = `
    position:fixed;bottom:80px;left:50%;transform:translateX(-50%);
    background:var(--surface2);border:1px solid var(--accent);
    color:var(--accent);padding:10px 20px;border-radius:8px;
    font-size:13px;z-index:999;animation:slideIn 0.3s ease;
    font-family:'DM Mono',monospace;
  `;
  t.textContent = msg;
  document.body.appendChild(t);
  setTimeout(() => t.remove(), duration);
}

// â”€â”€ Init â”€â”€
document.getElementById('player-name-input').addEventListener('keydown', e => {
  if (e.key === 'Enter') setName();
});
document.getElementById('join-code-input').addEventListener('keydown', e => {
  if (e.key === 'Enter') joinRoom();
});
document.getElementById('join-code-input').addEventListener('input', e => {
  e.target.value = e.target.value.toUpperCase();
});

// Hide loading after 1s init
setTimeout(() => {
  document.getElementById('loading').style.display = 'none';
  document.getElementById('lobby').style.display = 'flex';
}, 1000);

</script>
</body>
</html>
