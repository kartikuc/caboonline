<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>CABO ‚Äî Online Card Game</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=Playfair+Display:wght@400;700;900&family=DM+Mono:wght@300;400;500&display=swap');

  :root {
    --bg: #0a0a0f;
    --surface: #13131a;
    --surface2: #1e1e2a;
    --border: #2a2a3a;
    --accent: #c8a96e;
    --accent2: #e8c98e;
    --red: #e05555;
    --green: #55b87a;
    --blue: #5599e0;
    --purple: #9966cc;
    --text: #e8e8f0;
    --muted: #888899;
    --card-w: 62px;
    --card-h: 88px;
  }

  * { box-sizing: border-box; margin: 0; padding: 0; }
  html, body { height: 100%; overflow: hidden; }
  body { background: var(--bg); color: var(--text); font-family: 'DM Mono', monospace; height: 100vh; }

  /* ‚îÄ‚îÄ‚îÄ LOBBY ‚îÄ‚îÄ‚îÄ */
  #lobby {
    display: flex; flex-direction: column; align-items: center; justify-content: center;
    height: 100vh; gap: 24px; padding: 24px;
    background: radial-gradient(ellipse at 50% 0%, #1a1428 0%, var(--bg) 70%);
    overflow-y: auto;
  }
  .logo {
    font-family: 'Playfair Display', serif; font-size: clamp(52px, 9vw, 88px);
    font-weight: 900; letter-spacing: 0.15em; color: var(--accent);
    text-shadow: 0 0 60px rgba(200,169,110,0.3);
  }
  .logo::after {
    content: 'CARD GAME'; display: block; font-size: 0.17em; letter-spacing: 0.5em;
    color: var(--muted); text-align: center; font-family: 'DM Mono', monospace;
    font-weight: 300; margin-top: 4px;
  }
  .lobby-box {
    background: var(--surface); border: 1px solid var(--border);
    border-radius: 16px; padding: 26px; width: 100%; max-width: 420px;
    display: flex; flex-direction: column; gap: 14px;
  }
  .lobby-box h2 { font-family: 'Playfair Display', serif; font-size: 22px; color: var(--accent); }
  label { font-size: 11px; letter-spacing: 0.1em; color: var(--muted); text-transform: uppercase; }
  input[type=text] {
    width: 100%; padding: 11px 14px; background: var(--surface2); border: 1px solid var(--border);
    border-radius: 8px; color: var(--text); font-family: 'DM Mono', monospace;
    font-size: 15px; outline: none; transition: border-color 0.2s;
  }
  input[type=text]:focus { border-color: var(--accent); }
  .btn {
    padding: 11px 20px; border-radius: 8px; border: none;
    font-family: 'DM Mono', monospace; font-size: 13px; font-weight: 500;
    cursor: pointer; transition: all 0.15s; letter-spacing: 0.05em;
  }
  .btn-primary { background: var(--accent); color: #0a0a0f; }
  .btn-primary:hover { background: var(--accent2); transform: translateY(-1px); }
  .btn-secondary { background: var(--surface2); color: var(--text); border: 1px solid var(--border); }
  .btn-secondary:hover { border-color: var(--accent); color: var(--accent); }
  .btn:disabled { opacity: 0.4; cursor: not-allowed; transform: none !important; }
  .btn.loading { opacity: 0.7; cursor: not-allowed; transform: none !important; pointer-events: none; }
  .btn.loading::after {
    content: ''; display: inline-block; width: 11px; height: 11px;
    border: 2px solid currentColor; border-top-color: transparent; border-radius: 50%;
    animation: spin 0.7s linear infinite; margin-left: 8px; vertical-align: middle; opacity: 0.8;
  }
  .divider { display: flex; align-items: center; gap: 10px; color: var(--muted); font-size: 11px; }
  .divider::before, .divider::after { content: ''; flex: 1; height: 1px; background: var(--border); }
  .room-code-display { background: var(--surface2); border: 1px dashed var(--accent); border-radius: 8px; padding: 14px; text-align: center; }
  .room-code-display .code { font-size: 30px; letter-spacing: 0.3em; color: var(--accent); font-family: 'Playfair Display', serif; font-weight: 700; }
  .room-code-display .hint { font-size: 11px; color: var(--muted); margin-top: 4px; }
  .player-list { display: flex; flex-direction: column; gap: 7px; }
  .player-item {
    display: flex; align-items: center; gap: 9px;
    padding: 9px 12px; background: var(--surface2); border-radius: 7px;
    border: 1px solid var(--border); font-size: 13px;
  }
  .player-item.me { border-color: var(--accent); }
  .player-dot { width: 8px; height: 8px; border-radius: 50%; background: var(--green); flex-shrink: 0; }
  .player-item .host-badge { margin-left: auto; font-size: 10px; color: var(--accent); }
  .power-legend { display: flex; flex-wrap: wrap; gap: 4px; justify-content: center; font-size: 10px; }
  .pl-item { padding: 2px 6px; border-radius: 4px; border: 1px solid var(--border); color: var(--muted); }
  .pl-peek { border-color: rgba(85,184,122,0.4); color: #55b87a; }
  .pl-spy { border-color: rgba(85,153,224,0.4); color: #5599e0; }
  .pl-swap { border-color: rgba(153,102,204,0.4); color: #9966cc; }
  .pl-king { border-color: rgba(200,169,110,0.4); color: var(--accent); }

  /* ‚îÄ‚îÄ‚îÄ GAME SHELL ‚îÄ‚îÄ‚îÄ */
  #game { display: none; height: 100vh; flex-direction: column; overflow: hidden; }

  .game-header {
    display: flex; align-items: center; justify-content: space-between;
    padding: 8px 16px; background: var(--surface);
    border-bottom: 1px solid var(--border); flex-shrink: 0;
  }
  .game-title { font-family: 'Playfair Display', serif; font-size: 20px; color: var(--accent); }
  .turn-info { font-size: 12px; color: var(--muted); text-align: center; }
  #turn-label { font-size: 14px; }

  .score-strip {
    display: flex; gap: 6px; padding: 6px 14px; background: var(--surface2);
    border-bottom: 1px solid var(--border); overflow-x: auto; flex-shrink: 0;
  }
  .score-badge {
    display: flex; flex-direction: column; align-items: center;
    padding: 4px 12px; background: var(--surface); border-radius: 7px;
    border: 1px solid var(--border); min-width: 70px; flex-shrink: 0; font-size: 11px; gap: 1px;
  }
  .score-badge.active-player { border-color: var(--accent); }
  .score-badge .sname { color: var(--muted); overflow: hidden; white-space: nowrap; max-width: 80px; text-overflow: ellipsis; }
  .score-badge .sval { color: var(--text); font-size: 16px; font-family: 'Playfair Display', serif; }

  .game-main { flex: 1; display: flex; overflow: hidden; min-height: 0; }

  /* ‚îÄ‚îÄ‚îÄ BOARD ‚îÄ‚îÄ‚îÄ */
  .game-board { flex: 1; display: flex; flex-direction: column; gap: 8px; padding: 8px 12px; overflow-y: auto; min-height: 0; }

  .opponents-area { display: flex; flex-wrap: wrap; gap: 8px; justify-content: center; }
  .opponent-zone {
    background: var(--surface); border: 1px solid var(--border);
    border-radius: 10px; padding: 9px; min-width: 150px;
    display: flex; flex-direction: column; gap: 7px; align-items: center;
    transition: border-color 0.3s, box-shadow 0.3s;
  }
  .opponent-zone.active-turn { border-color: var(--accent); box-shadow: 0 0 16px rgba(200,169,110,0.2); }
  .opponent-name { font-size: 12px; color: var(--muted); }

  .center-area { display: flex; align-items: center; justify-content: center; gap: 18px; flex-wrap: wrap; }
  .pile-container { display: flex; flex-direction: column; align-items: center; gap: 5px; }
  .pile-label { font-size: 10px; letter-spacing: 0.12em; color: var(--muted); text-transform: uppercase; }

  /* ‚îÄ‚îÄ‚îÄ CARD ‚îÄ‚îÄ‚îÄ */
  .card {
    width: var(--card-w); height: var(--card-h);
    border-radius: 8px; border: 1px solid var(--border);
    cursor: pointer; transition: transform 0.15s, box-shadow 0.15s;
    display: flex; align-items: center; justify-content: center;
    position: relative; user-select: none; flex-shrink: 0;
    font-family: 'Playfair Display', serif;
    perspective: 600px;
  }
  .card.face-down {
    background: linear-gradient(135deg, #1e1e35 0%, #2a2a45 50%, #1e1e35 100%);
  }
  .card.face-down::after { content: '‚ú¶'; color: var(--accent); opacity: 0.3; font-size: 20px; }

  /* Real card face */
  .card.face-up {
    background: #f8f4ed; color: #1a1a1a;
    flex-direction: column; justify-content: space-between;
    padding: 4px 5px; overflow: hidden;
  }
  .card.face-up.red-suit { color: #c0392b; }

  .card-top { display: flex; flex-direction: column; align-items: flex-start; line-height: 1.1; }
  .card-bot { display: flex; flex-direction: column; align-items: flex-end; line-height: 1.1; transform: rotate(180deg); }
  .card-rank { font-size: 14px; font-weight: 700; }
  .card-suit-sm { font-size: 11px; }
  .card-center-pip { font-size: 26px; text-align: center; flex: 1; display: flex; align-items: center; justify-content: center; }

  /* Special power colored borders */
  .card.peek-card { box-shadow: inset 0 0 0 2px rgba(85,184,122,0.7) !important; }
  .card.spy-card { box-shadow: inset 0 0 0 2px rgba(85,153,224,0.7) !important; }
  .card.swap-card { box-shadow: inset 0 0 0 2px rgba(153,102,204,0.7) !important; }
  .card.king-card { box-shadow: inset 0 0 0 2px rgba(200,169,110,0.9) !important; }

  .card:hover:not(.not-selectable) { transform: translateY(-4px); box-shadow: 0 8px 18px rgba(0,0,0,0.5); }
  .card.selected { transform: translateY(-7px) !important; box-shadow: 0 0 0 2px var(--accent), 0 10px 22px rgba(0,0,0,0.5) !important; }
  .card.selectable:hover { border-color: var(--accent); }
  .card.not-selectable { cursor: default; }
  .card.not-selectable:hover { transform: none !important; box-shadow: none !important; }

  /* 4 cards in a row */
  .hand-row { display: flex; gap: 5px; flex-wrap: nowrap; justify-content: center; }

  .deck-card {
    background: linear-gradient(135deg, #1e1e35 0%, #2a2a45 100%);
    position: relative; overflow: hidden;
  }
  .deck-card::before {
    content: attr(data-count); position: absolute; bottom: 4px; right: 6px;
    font-size: 9px; color: var(--accent); opacity: 0.7; font-family: 'DM Mono', monospace;
  }
  .discard-empty {
    width: var(--card-w); height: var(--card-h); border-radius: 8px;
    border: 2px dashed var(--border); display: flex; align-items: center;
    justify-content: center; color: var(--border); font-size: 20px;
  }

  /* ‚îÄ‚îÄ‚îÄ MY AREA ‚îÄ‚îÄ‚îÄ */
  .my-area {
    background: var(--surface); border: 1px solid var(--border);
    border-radius: 10px; padding: 10px;
    display: flex; flex-direction: column; gap: 7px; align-items: center;
    transition: border-color 0.3s;
  }
  .my-area.my-turn { border-color: var(--accent); }

  /* drawn card */
  .drawn-area {
    display: flex; flex-direction: column; align-items: center; gap: 5px;
    padding: 9px; background: var(--surface2); border-radius: 9px;
    border: 1px dashed var(--border);
  }
  .drawn-area-label { font-size: 10px; color: var(--muted); letter-spacing: 0.1em; text-transform: uppercase; }

  /* log */
  .log-panel {
    max-height: 54px; overflow-y: auto; width: 100%;
    display: flex; flex-direction: column-reverse; gap: 2px;
  }
  .log-entry { font-size: 11px; color: var(--muted); }
  .log-entry .lname { color: var(--accent); }

  /* ‚îÄ‚îÄ‚îÄ CHAT ‚îÄ‚îÄ‚îÄ */
  .chat-panel {
    width: 220px; flex-shrink: 0; display: flex; flex-direction: column;
    border-left: 1px solid var(--border); background: var(--surface); overflow: hidden;
  }
  .chat-header { padding: 8px 12px; border-bottom: 1px solid var(--border); font-size: 11px; letter-spacing: 0.1em; color: var(--muted); text-transform: uppercase; flex-shrink: 0; }
  .chat-messages { flex: 1; overflow-y: auto; padding: 8px 10px; display: flex; flex-direction: column; gap: 6px; }
  .chat-msg { font-size: 12px; line-height: 1.4; }
  .chat-msg .cname { color: var(--accent); font-size: 10px; }
  .chat-msg.me .cname { color: var(--accent2); }
  .chat-msg .cbody { color: var(--text); word-break: break-word; }
  .chat-msg.system .cbody { color: var(--muted); font-style: italic; }
  .chat-input-area { padding: 8px 10px; border-top: 1px solid var(--border); display: flex; gap: 6px; flex-shrink: 0; }
  .chat-input-area input {
    flex: 1; padding: 7px 9px; background: var(--surface2);
    border: 1px solid var(--border); border-radius: 6px; color: var(--text);
    font-family: 'DM Mono', monospace; font-size: 11px; outline: none;
  }
  .chat-input-area input:focus { border-color: var(--accent); }
  .chat-send-btn { padding: 7px 10px; background: var(--accent); color: #0a0a0f; border: none; border-radius: 6px; cursor: pointer; font-size: 12px; transition: background 0.15s; }
  .chat-send-btn:hover { background: var(--accent2); }

  /* ‚îÄ‚îÄ‚îÄ BOTTOM BAR ‚îÄ‚îÄ‚îÄ */
  .bottom-bar {
    display: flex; align-items: center; justify-content: space-between;
    padding: 6px 14px; background: var(--surface2);
    border-top: 1px solid var(--border); flex-shrink: 0; gap: 10px; min-height: 42px;
  }
  .help-text { font-size: 12px; color: var(--muted); flex: 1; }

  .btn-action { font-size: 12px; padding: 8px 14px; white-space: nowrap; }
  .btn-danger { background: rgba(224,85,85,0.15); color: var(--red); border: 1px solid rgba(224,85,85,0.3); }
  .btn-danger:hover:not(:disabled) { background: rgba(224,85,85,0.25); border-color: var(--red); }
  .btn-success { background: rgba(85,184,122,0.15); color: var(--green); border: 1px solid rgba(85,184,122,0.3); }
  .btn-success:hover { background: rgba(85,184,122,0.25); border-color: var(--green); }

  /* ‚îÄ‚îÄ‚îÄ MODAL ‚îÄ‚îÄ‚îÄ */
  .modal-overlay {
    position: fixed; inset: 0; background: rgba(0,0,0,0.75);
    display: flex; align-items: center; justify-content: center;
    z-index: 100; backdrop-filter: blur(4px);
    opacity: 0; pointer-events: none; transition: opacity 0.2s;
  }
  .modal-overlay.open { opacity: 1; pointer-events: all; }
  .modal {
    background: var(--surface); border: 1px solid var(--border);
    border-radius: 14px; padding: 26px; max-width: 380px; width: 92%;
    text-align: center; display: flex; flex-direction: column; gap: 14px;
    transform: scale(0.95); transition: transform 0.2s; max-height: 88vh; overflow-y: auto;
  }
  .modal-overlay.open .modal { transform: scale(1); }
  .modal h2 { font-family: 'Playfair Display', serif; font-size: 24px; color: var(--accent); }
  .modal p { font-size: 13px; color: var(--muted); line-height: 1.6; }
  .score-table { text-align: left; font-size: 12px; width: 100%; }
  .score-row { display: flex; justify-content: space-between; padding: 6px 0; border-bottom: 1px solid var(--border); gap: 8px; }
  .score-row.winner { color: var(--green); }
  .status-chip { padding: 3px 8px; border-radius: 20px; font-size: 10px; display: inline-block; }
  .chip-cabo { background: rgba(200,169,110,0.15); color: var(--accent); border: 1px solid var(--accent); }

  /* ‚îÄ‚îÄ‚îÄ SHARED EVENT OVERLAY ‚îÄ‚îÄ‚îÄ */
  /* Event banner ‚Äî shown to all players describing what happened */
  .event-banner {
    position: fixed; top: 60px; left: 50%; transform: translateX(-50%);
    background: var(--surface); border: 1px solid var(--accent);
    border-radius: 10px; padding: 10px 22px;
    font-size: 13px; color: var(--text); z-index: 200;
    text-align: center; pointer-events: none;
    animation: bannerIn 0.35s ease forwards;
    box-shadow: 0 4px 20px rgba(0,0,0,0.5);
    max-width: 340px;
  }
  .event-banner .ev-title { color: var(--accent); font-size: 11px; letter-spacing: 0.1em; text-transform: uppercase; margin-bottom: 3px; }

  /* Censored overlay on a card (visible to everyone except the peeker) */
  .censored-overlay {
    position: absolute; inset: 0; border-radius: 7px;
    background: linear-gradient(135deg, #1a1a30, #2a1a3a);
    display: flex; flex-direction: column; align-items: center; justify-content: center;
    gap: 3px; z-index: 10; pointer-events: none;
    animation: censorIn 0.3s ease forwards;
  }
  .censored-overlay .cens-icon { font-size: 18px; }
  .censored-overlay .cens-text { font-size: 8px; color: var(--purple); letter-spacing: 0.08em; text-transform: uppercase; font-family: 'DM Mono', monospace; }

  /* Swap animation ‚Äî flying card ghost between two positions */
  .swap-ghost {
    position: fixed; z-index: 300; pointer-events: none;
    width: var(--card-w); height: var(--card-h);
    border-radius: 8px; border: 2px solid var(--purple);
    background: rgba(153,102,204,0.3);
    display: flex; align-items: center; justify-content: center;
    font-size: 22px; color: var(--purple);
    animation: swapGhost 0.6s ease forwards;
  }
  @keyframes swapGhost {
    0% { opacity: 0; transform: scale(0.8); }
    20% { opacity: 1; transform: scale(1.1); }
    80% { opacity: 1; transform: scale(1.1); }
    100% { opacity: 0; transform: scale(0.8); }
  }

  /* Card flip reveal animation (for peeker) */
  @keyframes flipReveal {
    0% { transform: rotateY(0deg); }
    50% { transform: rotateY(90deg); }
    100% { transform: rotateY(0deg); }
  }
  .card.flipping { animation: flipReveal 0.5s ease; }

  @keyframes bannerIn {
    from { opacity: 0; transform: translateX(-50%) translateY(-10px); }
    to { opacity: 1; transform: translateX(-50%) translateY(0); }
  }
  @keyframes censorIn {
    from { opacity: 0; transform: scale(1.05); }
    to { opacity: 1; transform: scale(1); }
  }

  /* Card highlight pulse (target of swap) */
  @keyframes highlightPulse {
    0%, 100% { box-shadow: 0 0 0 2px var(--purple); }
    50% { box-shadow: 0 0 0 4px var(--purple), 0 0 16px rgba(153,102,204,0.5); }
  }
  .card.swap-target { animation: highlightPulse 0.7s ease 2; }

  /* loading overlay */
  .loading-overlay {
    position: fixed; inset: 0; background: var(--bg);
    display: flex; flex-direction: column; align-items: center; justify-content: center;
    z-index: 200; gap: 14px;
  }
  .spinner { width: 36px; height: 36px; border: 3px solid var(--border); border-top-color: var(--accent); border-radius: 50%; animation: spin 0.8s linear infinite; }

  @keyframes pulse { 0%,100%{opacity:1}50%{opacity:0.5} }
  .pulsing { animation: pulse 1.5s ease-in-out infinite; }
  @keyframes spin { to { transform: rotate(360deg); } }
</style>
</head>
<body>

<div class="loading-overlay" id="loading">
  <div style="font-family:'Playfair Display',serif;font-size:38px;color:var(--accent)">CABO</div>
  <div class="spinner"></div>
  <div style="font-size:12px;color:var(--muted)">Connecting...</div>
</div>

<!-- LOBBY -->
<div id="lobby" style="display:none">
  <div class="logo">CABO</div>

  <div class="lobby-box" id="enter-name-box">
    <h2>Welcome</h2>
    <div>
      <label>Your Name</label>
      <input type="text" id="player-name-input" placeholder="Enter your name..." maxlength="20" />
    </div>
    <button class="btn btn-primary" onclick="setName()">Continue ‚Üí</button>
  </div>

  <div class="lobby-box" id="lobby-main" style="display:none">
    <h2>Play Cabo</h2>
    <button class="btn btn-primary" onclick="createRoom()">üé≤ Create New Room</button>
    <div class="divider">or join existing</div>
    <div>
      <label>Room Code</label>
      <input type="text" id="join-code-input" placeholder="4-letter code..." maxlength="4"
        style="text-transform:uppercase;letter-spacing:0.2em;font-size:18px" />
    </div>
    <button class="btn btn-secondary" onclick="joinRoom()">Join Room ‚Üí</button>
    <div class="power-legend">
      <span class="pl-item pl-peek">7/8 Peek own</span>
      <span class="pl-item pl-spy">9/10 Spy opp.</span>
      <span class="pl-item pl-swap">J Blind Swap</span>
      <span class="pl-item pl-swap">Q Peek opp+Swap</span>
      <span class="pl-item pl-king">K Peek both+Swap</span>
      <span class="pl-item pl-king">K‚ô† = 0 pts</span>
    </div>
  </div>

  <div class="lobby-box" id="waiting-room" style="display:none">
    <h2>Room Ready</h2>
    <div class="room-code-display">
      <div class="code" id="display-room-code">ABCD</div>
      <div class="hint">Share this code with friends</div>
    </div>
    <div>
      <label style="margin-bottom:6px;display:block">Players (<span id="player-count">1</span>/6)</label>
      <div class="player-list" id="player-list"></div>
    </div>
    <button class="btn btn-primary" id="start-btn" onclick="startGame()" disabled>Start Game (need 2+)</button>
    <button class="btn btn-secondary" onclick="leaveRoom()">‚Üê Leave</button>
  </div>
</div>

<!-- GAME -->
<div id="game">
  <div class="game-header">
    <div class="game-title">CABO</div>
    <div class="turn-info">
      <div id="turn-label" class="pulsing">Loading...</div>
      <div id="round-label" style="font-size:11px;color:var(--muted);margin-top:1px">Round 1</div>
    </div>
    <div id="cabo-status"></div>
  </div>

  <div class="score-strip" id="score-strip"></div>

  <div class="game-main">
    <!-- Board -->
    <div class="game-board">
      <div class="opponents-area" id="opponents-area"></div>

      <div class="center-area">
        <div class="pile-container">
          <div class="pile-label">Draw Pile</div>
          <div class="card deck-card face-down" id="deck-pile" data-count="" onclick="drawFromDeck()">
            <span style="color:var(--accent);opacity:0.3;font-size:20px">‚ú¶</span>
          </div>
        </div>

        <div id="drawn-card-area" style="display:none">
          <div class="drawn-area">
            <div class="drawn-area-label">Drawn Card</div>
            <div class="card face-up" id="drawn-card-display" style="cursor:default"></div>
            <div style="display:flex;gap:5px;margin-top:4px;flex-wrap:wrap;justify-content:center">
              <button class="btn btn-secondary btn-action" onclick="discardDrawnCard()">Discard</button>
              <button class="btn btn-success btn-action" id="use-power-btn" onclick="usePower()" style="display:none">Use Power</button>
            </div>
          </div>
        </div>

        <div class="pile-container">
          <div class="pile-label">Discard Pile</div>
          <div id="discard-pile-display"><div class="discard-empty">+</div></div>
        </div>
      </div>

      <div class="my-area" id="my-area">
        <div style="font-size:11px;color:var(--muted)" id="my-name-label">You</div>
        <div class="hand-row" id="my-cards"></div>
      </div>

      <div class="log-panel" id="log-panel"></div>
    </div>

    <!-- Chat -->
    <div class="chat-panel">
      <div class="chat-header">üí¨ Chat</div>
      <div class="chat-messages" id="chat-messages"></div>
      <div class="chat-input-area">
        <input type="text" id="chat-input" placeholder="Message..." maxlength="120" />
        <button class="chat-send-btn" onclick="sendChat()">‚Üë</button>
      </div>
    </div>
  </div>

  <div class="bottom-bar">
    <div class="help-text" id="help-text">Waiting...</div>
    <button class="btn btn-action btn-danger" id="cabo-btn" onclick="callCabo()">üì£ Call CABO</button>
  </div>
</div>

<!-- Modals -->
<div class="modal-overlay" id="round-modal">
  <div class="modal">
    <h2>Round Over!</h2>
    <div id="round-modal-content"></div>
    <button class="btn btn-primary" id="next-round-btn" onclick="nextRound()" style="display:none">Next Round ‚Üí</button>
    <button class="btn btn-secondary" onclick="closeRoundModal()">Close</button>
  </div>
</div>
<div class="modal-overlay" id="game-over-modal">
  <div class="modal">
    <h2 id="gameover-title">Game Over!</h2>
    <div id="gameover-content"></div>
    <button class="btn btn-primary" onclick="playAgain()">Play Again</button>
  </div>
</div>

<script type="module">
import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-app.js";
import { getDatabase, ref, set, get, update, onValue, push, remove, off }
  from "https://www.gstatic.com/firebasejs/10.12.2/firebase-database.js";

// ‚ïê‚ïê PASTE YOUR FIREBASE CONFIG HERE ‚ïê‚ïê
const firebaseConfig = {
  apiKey: "AIzaSyDvuECKAQvX4WY9UwBYHXrkGcivcBKwd8c",
  authDomain: "cabo-1611d.firebaseapp.com",
  databaseURL: "https://cabo-1611d-default-rtdb.firebaseio.com",
  projectId: "cabo-1611d",
  storageBucket: "cabo-1611d.firebasestorage.app",
  messagingSenderId: "507007893312",
  appId: "1:507007893312:web:139152ef2e57c7235584a5"
};

const app = initializeApp(firebaseConfig);
const db = getDatabase(app);

// ‚ïê‚ïê STATE ‚ïê‚ïê
let myId = null, myName = '', roomCode = null, roomRef = null;
let gameState = null, isHost = false;
let pendingAction = null;
let initialPeekCount = 0, initialPeekDone = false;
const myKnownCards = new Map(); // pos ‚Üí card (local memory)
let lastEventId = null; // track last processed shared event

const SUIT_RED = new Set(['‚ô•','‚ô¶']);

// ‚îÄ‚îÄ Suit pip patterns (how many rows/cols for each value) ‚îÄ‚îÄ
// Returns array of pip strings to render in center of card
function getSuitPips(face, suit) {
  if (face === 0) return ['‚òÖ']; // joker/K‚ô†
  if (face === 1) return [suit]; // Ace: single big pip
  // Face cards: just show letter
  if (face >= 11) return null;
  // Number pips
  const pip = suit;
  const counts = { 2:[pip,pip], 3:[pip,pip,pip], 4:[pip,pip,pip,pip],
    5:[pip,pip,pip,pip,pip], 6:[pip,pip,pip,pip,pip,pip],
    7:[pip,pip,pip,pip,pip,pip,pip], 8:[pip,pip,pip,pip,pip,pip,pip,pip],
    9:[pip,pip,pip,pip,pip,pip,pip,pip,pip], 10:[pip,pip,pip,pip,pip,pip,pip,pip,pip,pip] };
  return counts[face] || [pip];
}

// ‚îÄ‚îÄ Deck builder ‚îÄ‚îÄ
function buildDeck() {
  const suits = ['‚ô†','‚ô•','‚ô¶','‚ô£'];
  const deck = [];
  for (let f = 1; f <= 13; f++) {
    for (const s of suits) {
      const value = (f === 13 && s === '‚ô†') ? 0 : f; // K‚ô† = 0pts
      deck.push({ face: f, suit: s, value });
    }
  }
  // 2 Jokers
  deck.push({ face: 0, suit: '‚òÖ', value: 0 });
  deck.push({ face: 0, suit: '‚òÖ', value: 0 });
  return deck;
}

function shuffle(arr) {
  const a = [...arr];
  for (let i = a.length-1; i > 0; i--) {
    const j = Math.floor(Math.random()*(i+1));
    [a[i],a[j]] = [a[j],a[i]];
  }
  return a;
}

function cardPower(card) {
  if (!card) return null;
  const f = card.face ?? card.value;
  if (f === 7 || f === 8) return 'peek';
  if (f === 9 || f === 10) return 'spy';
  if (f === 11) return 'blindswap';
  if (f === 12) return 'peekswap';
  if (f === 13) return 'kingswap';
  return null;
}

function cardLabel(card) {
  if (!card) return '?';
  const f = card.face ?? card.value;
  if (!f || card.suit === '‚òÖ') return '‚òÖ';
  if (f === 1) return 'A';
  if (f === 11) return 'J';
  if (f === 12) return 'Q';
  if (f === 13) return 'K';
  return String(f);
}

function isRedCard(card) { return card && SUIT_RED.has(card.suit); }

// ‚îÄ‚îÄ Build a proper card element with real face ‚îÄ‚îÄ
function makeCardEl(card, opts = {}) {
  const el = document.createElement('div');
  el.className = 'card';

  if (!card || opts.faceDown) {
    el.classList.add('face-down');
    return el;
  }

  el.classList.add('face-up');
  if (isRedCard(card)) el.classList.add('red-suit');

  const p = cardPower(card);
  if (p === 'peek') el.classList.add('peek-card');
  else if (p === 'spy') el.classList.add('spy-card');
  else if (p === 'blindswap' || p === 'peekswap') el.classList.add('swap-card');
  else if (p === 'kingswap') el.classList.add('king-card');

  const lbl = cardLabel(card);
  const suit = card.suit || '';
  const f = card.face ?? card.value;
  const isFace = f >= 11 || f === 0 || f === 1;

  // Top-left corner
  const top = document.createElement('div');
  top.className = 'card-top';
  top.innerHTML = `<span class="card-rank">${lbl}</span><span class="card-suit-sm">${suit}</span>`;

  // Center
  const center = document.createElement('div');
  center.className = 'card-center-pip';
  if (isFace) {
    // Face card: big symbol
    center.style.fontSize = '28px';
    center.textContent = suit;
  } else {
    // Pip cards: grid of suit symbols
    const pips = getSuitPips(f, suit);
    center.style.cssText = 'display:grid;grid-template-columns:repeat(2,1fr);gap:1px;font-size:10px;align-items:center;justify-items:center;flex:1;width:100%;padding:2px;';
    if (f === 1 || f === 2 || f === 3) {
      center.style.gridTemplateColumns = '1fr';
      center.style.fontSize = f === 1 ? '22px' : '13px';
    }
    (pips || [suit]).forEach(p => {
      const s = document.createElement('span');
      s.textContent = p;
      center.appendChild(s);
    });
  }

  // Bottom-right corner (rotated)
  const bot = document.createElement('div');
  bot.className = 'card-bot';
  bot.innerHTML = `<span class="card-rank">${lbl}</span><span class="card-suit-sm">${suit}</span>`;

  el.appendChild(top);
  el.appendChild(center);
  el.appendChild(bot);
  return el;
}

// ‚îÄ‚îÄ CENSORED overlay card (shown to others during peek) ‚îÄ‚îÄ
function makeCensoredCard() {
  const el = document.createElement('div');
  el.className = 'card face-down';
  const overlay = document.createElement('div');
  overlay.className = 'censored-overlay';
  overlay.innerHTML = `<span class="cens-icon">üîí</span><span class="cens-text">Censored</span>`;
  el.appendChild(overlay);
  return el;
}

// ‚ïê‚ïê LOBBY ‚ïê‚ïê
function showScreen(id) {
  document.getElementById('loading').style.display = 'none';
  document.getElementById('lobby').style.display = id === 'lobby' ? 'flex' : 'none';
  document.getElementById('game').style.display = id === 'game' ? 'flex' : 'none';
}

function setLoading(btn, loading, text) {
  if (loading) {
    btn.dataset.origText = btn.textContent;
    if (text) btn.textContent = text;
    btn.classList.add('loading'); btn.disabled = true;
  } else {
    btn.textContent = btn.dataset.origText || btn.textContent;
    btn.classList.remove('loading'); btn.disabled = false;
  }
}

window.setName = function() {
  const n = document.getElementById('player-name-input').value.trim();
  if (!n) return;
  myName = n;
  document.getElementById('enter-name-box').style.display = 'none';
  document.getElementById('lobby-main').style.display = 'flex';
};

window.createRoom = async function() {
  const btn = event.currentTarget;
  setLoading(btn, true, 'Creating...');
  try {
    const code = Array.from({length:4}, () => 'ABCDEFGHJKLMNPQRSTUVWXYZ'[Math.floor(Math.random()*23)]).join('');
    roomCode = code; isHost = true;
    await joinRoomWithCode(code);
  } catch(e) { setLoading(btn, false); alert('Failed to create room.'); }
};

window.joinRoom = async function() {
  const code = document.getElementById('join-code-input').value.trim().toUpperCase();
  if (code.length !== 4) return alert('Enter a 4-letter room code');
  const btn = document.querySelector('#lobby-main .btn-secondary');
  setLoading(btn, true, 'Joining...');
  try {
    const snap = await get(ref(db, `rooms/${code}`));
    if (!snap.exists()) { setLoading(btn, false); return alert('Room not found'); }
    if (snap.val().state !== 'lobby') { setLoading(btn, false); return alert('Game already started'); }
    roomCode = code; isHost = false;
    await joinRoomWithCode(code);
  } catch(e) { setLoading(btn, false); alert('Failed to join room.'); }
};

async function joinRoomWithCode(code) {
  roomRef = ref(db, `rooms/${code}`);
  const playerRef = push(ref(db, `rooms/${code}/players`));
  myId = playerRef.key;
  const snap = await get(ref(db, `rooms/${code}/players`));
  const count = Object.keys(snap.val() || {}).length;
  await set(playerRef, { name: myName, id: myId, score: 0 });
  if (count === 0) {
    await set(ref(db, `rooms/${code}/state`), 'lobby');
    await set(ref(db, `rooms/${code}/host`), myId);
  }
  document.getElementById('display-room-code').textContent = code;
  document.getElementById('lobby-main').style.display = 'none';
  document.getElementById('waiting-room').style.display = 'flex';
  listenLobby();
}

function listenLobby() {
  const pr = ref(db, `rooms/${roomCode}/players`);
  onValue(pr, snap => {
    const arr = Object.values(snap.val() || {});
    document.getElementById('player-count').textContent = arr.length;
    const list = document.getElementById('player-list');
    list.innerHTML = '';
    arr.forEach(p => {
      const div = document.createElement('div');
      div.className = 'player-item' + (p.id === myId ? ' me' : '');
      div.innerHTML = `<div class="player-dot"></div><span>${p.name}</span>${p.id === arr[0]?.id ? '<span class="host-badge">HOST</span>' : ''}`;
      list.appendChild(div);
    });
    const sb = document.getElementById('start-btn');
    sb.disabled = arr.length < 2 || arr[0]?.id !== myId;
    sb.textContent = arr.length < 2 ? 'Start Game (need 2+)' : `Start Game (${arr.length} players)`;
  });
  const sr = ref(db, `rooms/${roomCode}/state`);
  onValue(sr, snap => { if (snap.val() === 'playing') { off(sr); initGame(); } });
}

window.leaveRoom = function() {
  if (roomCode && myId) remove(ref(db, `rooms/${roomCode}/players/${myId}`));
  location.reload();
};

window.startGame = async function() {
  if (!isHost) return;
  const btn = document.getElementById('start-btn');
  setLoading(btn, true, 'Starting...');
  const snap = await get(ref(db, `rooms/${roomCode}/players`));
  const playersObj = snap.val();
  const playerArr = Object.values(playersObj);
  const deck = shuffle(buildDeck());
  const hands = {};
  playerArr.forEach(p => { hands[p.id] = [deck.shift(), deck.shift(), deck.shift(), deck.shift()]; });
  const discard = deck.shift();
  const state = {
    deck, discard: [discard], hands,
    playerOrder: playerArr.map(p => p.id),
    playerNames: Object.fromEntries(playerArr.map(p => [p.id, p.name])),
    scores: Object.fromEntries(playerArr.map(p => [p.id, 0])),
    currentTurn: playerArr[0].id,
    caboCallerId: null, lastTurns: {},
    phase: 'initial-peek', drawnCard: null, round: 1, log: [],
    event: null
  };
  await set(roomRef, { state: 'playing', players: playersObj, host: myId, game: state });
};

// ‚ïê‚ïê GAME ‚ïê‚ïê
function initGame() {
  showScreen('game');
  onValue(ref(db, `rooms/${roomCode}/game`), snap => {
    if (!snap.exists()) return;
    gameState = snap.val();
    fixArrays(gameState);
    // Process shared event before render
    handleSharedEvent(gameState.event);
    renderGame();
  });
  onValue(ref(db, `rooms/${roomCode}/chat`), snap => {
    if (!snap.exists()) return;
    const arr = Object.values(snap.val());
    const container = document.getElementById('chat-messages');
    container.innerHTML = '';
    arr.slice(-80).forEach(m => {
      const div = document.createElement('div');
      div.className = 'chat-msg' + (m.id === myId ? ' me' : '') + (m.system ? ' system' : '');
      div.innerHTML = m.system ? `<span class="cbody">${m.text}</span>`
        : `<div class="cname">${m.name}</div><div class="cbody">${esc(m.text)}</div>`;
      container.appendChild(div);
    });
    container.scrollTop = container.scrollHeight;
  });
}

function fixArrays(gs) {
  if (gs.deck && !Array.isArray(gs.deck)) gs.deck = Object.values(gs.deck);
  if (gs.playerOrder && !Array.isArray(gs.playerOrder)) gs.playerOrder = Object.values(gs.playerOrder);
  if (gs.discard && !Array.isArray(gs.discard)) gs.discard = Object.values(gs.discard);
  if (gs.log && !Array.isArray(gs.log)) gs.log = Object.values(gs.log);
  (gs.playerOrder||[]).forEach(pid => {
    if (gs.hands?.[pid] && !Array.isArray(gs.hands[pid])) gs.hands[pid] = Object.values(gs.hands[pid]);
  });
}

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// SHARED EVENT SYSTEM
// Events are written to Firebase and all clients react
// Types: 'peek', 'spy', 'swap', 'cabo'
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function handleSharedEvent(event) {
  if (!event || event.id === lastEventId) return;
  lastEventId = event.id;

  const actorName = event.actorName || '?';
  const isMe = event.actorId === myId;

  if (event.type === 'peek') {
    // Show banner to everyone
    showBanner(`üëÅ ${actorName} peeked at their card`, isMe ? '(only you can see it)' : '');
    // For the peeker: show card revealed (handled in renderGame via myKnownCards)
    // For everyone else: show censored card on that position
    if (!isMe) {
      // Mark that position as "censored" for 3s
      censorCard(event.actorId, event.pos, 3000);
    }
  }

  if (event.type === 'spy') {
    const targetName = event.targetName || '?';
    showBanner(`üîç ${actorName} spied on ${targetName}'s card`, isMe ? `You saw: ${event.cardLabel}` : '');
    if (!isMe) {
      censorCard(event.targetId, event.pos, 3000);
    }
  }

  if (event.type === 'swap') {
    const targetName = event.targetName || '?';
    showBanner(`üîÑ ${actorName} swapped a card with ${targetName}`, '');
    // Flash both cards with swap-target class
    setTimeout(() => {
      flashSwapCards(event.actorId, event.myPos, event.targetId, event.oppPos);
    }, 100);
  }

  if (event.type === 'blindswap') {
    const targetName = event.targetName || '?';
    showBanner(`üîÑ ${actorName} blind-swapped with ${targetName}`, '(nobody sees the cards)');
    setTimeout(() => {
      flashSwapCards(event.actorId, event.myPos, event.targetId, event.oppPos);
    }, 100);
  }

  if (event.type === 'cabo') {
    showBanner(`üéØ ${actorName} called CABO!`, 'Everyone gets one more turn');
  }
}

// Map of censored positions: "pid:pos" ‚Üí timeout
const censoredCards = new Set();

function censorCard(pid, pos, duration) {
  const key = `${pid}:${pos}`;
  censoredCards.add(key);
  setTimeout(() => { censoredCards.delete(key); renderGame(); }, duration);
  renderGame(); // re-render immediately to show censored
}

function flashSwapCards(pid1, pos1, pid2, pos2) {
  // Find card elements by data attributes and add class
  const cards1 = getCardEls(pid1);
  const cards2 = getCardEls(pid2);
  if (cards1[pos1]) { cards1[pos1].classList.add('swap-target'); setTimeout(() => cards1[pos1]?.classList.remove('swap-target'), 1400); }
  if (cards2[pos2]) { cards2[pos2].classList.add('swap-target'); setTimeout(() => cards2[pos2]?.classList.remove('swap-target'), 1400); }
}

function getCardEls(pid) {
  if (pid === myId) {
    return [...document.getElementById('my-cards').querySelectorAll('.card')];
  }
  const zones = document.querySelectorAll('.opponent-zone');
  for (const zone of zones) {
    if (zone.dataset.pid === pid) return [...zone.querySelectorAll('.card')];
  }
  return [];
}

function showBanner(title, subtitle) {
  // Remove existing banners
  document.querySelectorAll('.event-banner').forEach(b => b.remove());
  const div = document.createElement('div');
  div.className = 'event-banner';
  div.innerHTML = `<div class="ev-title">${title}</div>${subtitle ? `<div style="font-size:11px;color:var(--muted);margin-top:2px">${subtitle}</div>` : ''}`;
  document.body.appendChild(div);
  setTimeout(() => div.remove(), 3500);
}

function broadcastEvent(eventData) {
  const id = Date.now() + '_' + Math.random().toString(36).slice(2, 7);
  return update(ref(db, `rooms/${roomCode}/game`), { event: { ...eventData, id } });
}

const isMyTurn = () => gameState?.currentTurn === myId;

function renderGame() {
  if (!gameState) return;
  const gs = gameState;
  const myTurn = isMyTurn();
  const currentName = gs.playerNames?.[gs.currentTurn] || '?';

  // Header
  const tl = document.getElementById('turn-label');
  tl.textContent = myTurn ? '‚ú® Your Turn' : `${currentName}'s Turn`;
  tl.style.color = myTurn ? 'var(--accent2)' : 'var(--text)';
  document.getElementById('round-label').textContent = `Round ${gs.round || 1}`;
  document.getElementById('cabo-status').innerHTML = gs.caboCallerId
    ? `<span class="status-chip chip-cabo">CABO ‚Äî ${gs.playerNames[gs.caboCallerId]}</span>` : '';

  // Scores
  const strip = document.getElementById('score-strip');
  strip.innerHTML = '';
  (gs.playerOrder||[]).forEach(pid => {
    const div = document.createElement('div');
    div.className = 'score-badge' + (pid === gs.currentTurn ? ' active-player' : '');
    div.innerHTML = `<span class="sname">${gs.playerNames[pid]}${pid===myId?' ‚òÖ':''}</span><span class="sval">${gs.scores?.[pid]??0}</span>`;
    strip.appendChild(div);
  });

  // Opponents
  const oppArea = document.getElementById('opponents-area');
  oppArea.innerHTML = '';
  (gs.playerOrder||[]).filter(pid => pid !== myId).forEach(pid => {
    const zone = document.createElement('div');
    zone.className = 'opponent-zone' + (pid === gs.currentTurn ? ' active-turn' : '');
    zone.dataset.pid = pid;
    const hand = gs.hands?.[pid] || [];
    const row = document.createElement('div');
    row.className = 'hand-row';

    hand.forEach((c, i) => {
      const isCensored = censoredCards.has(`${pid}:${i}`);
      let el;
      if (isCensored) {
        el = makeCensoredCard();
      } else {
        el = makeCardEl(c, { faceDown: true });
      }
      const pa = pendingAction;
      if (myTurn && pa) {
        const clickable =
          (pa.type === 'spy' && pa.step === 'pick-opp') ||
          (pa.type === 'peekswap' && pa.step === 'pick-opp') ||
          (pa.type === 'kingswap' && pa.step === 'pick-opp') ||
          (pa.type === 'kingswap' && pa.step === 'pick-opp-swap') ||
          (pa.type === 'blindswap' && pa.step === 'pick-opp');
        if (clickable) {
          el.classList.add('selectable');
          el.onclick = () => handleOppCardClick(pid, i);
        } else {
          el.classList.add('not-selectable');
        }
      } else {
        el.classList.add('not-selectable');
      }
      row.appendChild(el);
    });

    zone.innerHTML = `<div class="opponent-name">${gs.playerNames[pid]}</div>`;
    zone.appendChild(row);
    oppArea.appendChild(zone);
  });

  // Deck
  const deckEl = document.getElementById('deck-pile');
  deckEl.dataset.count = (gs.deck||[]).length;
  deckEl.style.opacity = (gs.deck||[]).length === 0 ? '0.3' : '1';
  deckEl.style.cursor = (myTurn && gs.phase==='play' && !gs.drawnCard && !pendingAction) ? 'pointer' : 'default';

  // Discard
  const discardArr = gs.discard||[];
  const top = discardArr[discardArr.length-1]||null;
  const dd = document.getElementById('discard-pile-display');
  if (top) {
    const el = makeCardEl(top); el.classList.add('not-selectable');
    dd.innerHTML=''; dd.appendChild(el);
  } else { dd.innerHTML='<div class="discard-empty">+</div>'; }

  // Drawn card
  const drawnArea = document.getElementById('drawn-card-area');
  if (gs.drawnCard && myTurn && !pendingAction) {
    drawnArea.style.display = 'block';
    const dDisp = document.getElementById('drawn-card-display');
    const newEl = makeCardEl(gs.drawnCard);
    newEl.id = 'drawn-card-display';
    newEl.style.cursor = 'default';
    dDisp.replaceWith(newEl);
    const power = cardPower(gs.drawnCard);
    const pb = document.getElementById('use-power-btn');
    if (power) {
      pb.style.display = 'block';
      pb.textContent = {peek:'üëÅ Peek Own', spy:'üîç Spy Opp.', blindswap:'üîÑ Blind Swap', peekswap:'üëÅüîÑ Peek+Swap', kingswap:'üëë King Swap'}[power];
    } else { pb.style.display='none'; }
  } else { drawnArea.style.display='none'; }

  // My hand ‚Äî 4 in a row
  const myHand = gs.hands?.[myId]||[];
  const myCardsEl = document.getElementById('my-cards');
  myCardsEl.innerHTML = '';
  document.getElementById('my-name-label').textContent = myName + ' (you)';
  document.getElementById('my-area').className = 'my-area' + (myTurn ? ' my-turn' : '');

  myHand.forEach((card, i) => {
    const known = myKnownCards.has(i);
    const pa = pendingAction;
    const kingShowMine = pa?.type==='kingswap' && pa.step==='peek-mine' && pa.myPos===i;
    const el = (known || kingShowMine) ? makeCardEl(card) : makeCardEl(card, { faceDown: true });

    if (gs.phase === 'initial-peek' && !initialPeekDone) {
      if (i === 2 || i === 3) {
        el.classList.add('selectable');
        el.onclick = () => doInitialPeek(i, card);
      } else { el.classList.add('not-selectable'); }
    } else if (gs.phase === 'play' && myTurn) {
      const pa = pendingAction;
      if (gs.drawnCard && !pa) {
        el.classList.add('selectable'); el.title='Swap in drawn card';
        el.onclick = () => swapWithMyCard(i);
      } else if (pa?.type==='peek' && pa.step==='pick') {
        el.classList.add('selectable'); el.onclick = () => doPeekReveal(i, card);
      } else if (pa?.type==='blindswap' && pa.step==='pick-mine') {
        el.classList.add('selectable'); el.onclick = () => { pendingAction.myPos=i; pendingAction.step='pick-opp'; renderGame(); };
      } else if (pa?.type==='peekswap' && pa.step==='pick-mine') {
        el.classList.add('selectable'); el.onclick = () => doPeekswapPickMine(i);
      } else if (pa?.type==='kingswap' && pa.step==='pick-mine') {
        el.classList.add('selectable'); el.onclick = () => doKingswapPickMine(i);
      } else { el.classList.add('not-selectable'); }
      if (pa?.myPos === i) el.classList.add('selected');
    } else { el.classList.add('not-selectable'); }

    myCardsEl.appendChild(el);
  });

  // Help text
  document.getElementById('help-text').textContent = helpText(gs, myTurn, currentName);

  // CABO btn
  document.getElementById('cabo-btn').disabled =
    !myTurn || !!gs.caboCallerId || gs.phase!=='play' || !!gs.drawnCard || !!pendingAction;

  // Log
  const logPanel = document.getElementById('log-panel');
  logPanel.innerHTML='';
  (gs.log||[]).slice(-5).reverse().forEach(e => {
    const div = document.createElement('div');
    div.className='log-entry'; div.innerHTML=e;
    logPanel.appendChild(div);
  });

  if (gs.phase==='round-end') showRoundEnd();
  if (gs.phase==='game-over' && !document.getElementById('game-over-modal').classList.contains('open'))
    showGameOverModal(gs.scores, gs.playerNames, gs.playerOrder);
}

function helpText(gs, myTurn, currentName) {
  if (gs.phase === 'initial-peek') return `Click your 2 bottom cards to peek at them (${2-initialPeekCount} left) ‚Äî they'll show for 3 seconds`;
  if (!myTurn) return `Waiting for ${currentName}...`;
  const pa = pendingAction;
  if (!gs.drawnCard && !pa) return 'Draw a card from the deck, or call CABO!';
  if (gs.drawnCard && !pa) return 'Discard it, or click one of your cards to swap it in';
  if (!pa) return '';
  const map = {
    'peek:pick': 'üëÅ Click one of YOUR cards to peek at it',
    'spy:pick-opp': 'üîç Click an OPPONENT\'S card to spy on it',
    'spy:revealed': 'üîç Peeked! Ending turn...',
    'blindswap:pick-mine': 'üîÑ Pick YOUR card for blind swap',
    'blindswap:pick-opp': 'üîÑ Now pick OPPONENT\'S card to swap with',
    'peekswap:pick-opp': 'üëÅüîÑ Pick OPPONENT\'S card to peek at first',
    'peekswap:peek-done': 'üëÅüîÑ Saw their card ‚Äî pick YOUR card to swap out',
    'peekswap:pick-mine': 'üëÅüîÑ Click YOUR card to swap out',
    'kingswap:pick-opp': 'üëë Pick OPPONENT\'S card to peek at',
    'kingswap:peek-done': 'üëë Now pick YOUR card to peek at',
    'kingswap:pick-mine': 'üëë Click YOUR card to peek at it',
    'kingswap:peek-mine': 'üëë Now pick OPPONENT\'S card to swap with',
    'kingswap:pick-opp-swap': 'üëë Pick OPPONENT\'S card to complete the swap',
  };
  return map[`${pa?.type}:${pa?.step}`] || '';
}

function handleOppCardClick(oppId, pos) {
  const pa = pendingAction;
  if (!pa) return;
  if (pa.type==='spy' && pa.step==='pick-opp') doSpyReveal(oppId, pos);
  else if (pa.type==='peekswap' && pa.step==='pick-opp') doPeekswapPickOpp(oppId, pos);
  else if (pa.type==='kingswap' && pa.step==='pick-opp') doKingswapPickOpp(oppId, pos);
  else if (pa.type==='kingswap' && pa.step==='pick-opp-swap') doKingswapSwap(oppId, pos);
  else if (pa.type==='blindswap' && pa.step==='pick-opp') doBlindswapFinish(oppId, pos);
}

// ‚îÄ‚îÄ Initial Peek (bottom 2 cards = index 2,3) ‚îÄ‚îÄ
function doInitialPeek(pos, card) {
  if (initialPeekCount >= 2 || initialPeekDone) return;
  initialPeekCount++;
  myKnownCards.set(pos, card);
  renderGame();
  // ‚Üê CHANGE PEEK REVEAL TIME HERE (currently 3000ms = 3 seconds)
  setTimeout(() => { myKnownCards.delete(pos); renderGame(); }, 3000);
  if (initialPeekCount >= 2) {
    initialPeekDone = true;
    update(ref(db, `rooms/${roomCode}/game/peekReady`), { [myId]: true });
    setTimeout(async () => {
      const snap = await get(ref(db, `rooms/${roomCode}/game/peekReady`));
      const ready = snap.val() || {};
      if ((gameState.playerOrder||[]).every(pid => ready[pid]))
        await update(ref(db, `rooms/${roomCode}/game`), { phase: 'play' });
    }, 500);
    // ‚Üê CHANGE HOST FORCE-START TIMEOUT HERE (currently 10000ms = 10 seconds)
    if (isHost) setTimeout(async () => {
      const snap = await get(ref(db, `rooms/${roomCode}/game/phase`));
      if (snap.val()==='initial-peek') await update(ref(db, `rooms/${roomCode}/game`), { phase:'play' });
    }, 10000);
  }
}

// ‚îÄ‚îÄ Draw ‚îÄ‚îÄ
window.drawFromDeck = async function() {
  if (!isMyTurn() || gameState.phase!=='play' || gameState.drawnCard || pendingAction) return;
  const gs = gameState;
  if (!gs.deck?.length) return;
  const deck = [...gs.deck];
  const drawn = deck.shift();
  await update(ref(db, `rooms/${roomCode}/game`), {
    deck, drawnCard: drawn,
    log: addLog(gs.log, `<span class="lname">${myName}</span> drew a card`)
  });
};

// ‚îÄ‚îÄ Discard ‚îÄ‚îÄ
window.discardDrawnCard = async function() {
  if (!isMyTurn() || !gameState.drawnCard) return;
  const gs = gameState;
  const lbl = cardLabel(gs.drawnCard);
  const updates = {
    drawnCard: null, discard: [...(gs.discard||[]), gs.drawnCard],
    log: addLog(gs.log, `<span class="lname">${myName}</span> discarded ${lbl}${gs.drawnCard.suit}`)
  };
  Object.assign(updates, nextTurn(gs));
  await update(ref(db, `rooms/${roomCode}/game`), updates);
};

// ‚îÄ‚îÄ Use Power ‚îÄ‚îÄ
window.usePower = function() {
  if (!isMyTurn() || !gameState.drawnCard) return;
  const power = cardPower(gameState.drawnCard);
  if (!power) return;
  pendingAction = { type: power, drawnCard: gameState.drawnCard, step: {peek:'pick',spy:'pick-opp',blindswap:'pick-mine',peekswap:'pick-opp',kingswap:'pick-opp'}[power] };
  renderGame();
};

// ‚îÄ‚îÄ Peek Own (7/8) ‚îÄ‚îÄ
function doPeekReveal(pos, card) {
  myKnownCards.set(pos, card);
  const lbl = cardLabel(card);
  renderGame(); // show face-up to me
  // Broadcast censored event to others
  broadcastEvent({ type:'peek', actorId:myId, actorName:myName, pos, cardLabel:`${lbl}${card.suit}` });
  showToast(`Card ${pos+1}: ${lbl}${card.suit} = ${card.value}pts`, 3000);
  // ‚Üê CHANGE PEEK REVEAL TIME HERE (currently 3000ms)
  setTimeout(() => { myKnownCards.delete(pos); renderGame(); }, 3000);
  const gs = gameState;
  const updates = {
    drawnCard: null, discard: [...(gs.discard||[]), pendingAction.drawnCard],
    log: addLog(gs.log, `<span class="lname">${myName}</span> peeked at their own card`)
  };
  pendingAction = null;
  Object.assign(updates, nextTurn(gs));
  update(ref(db, `rooms/${roomCode}/game`), updates);
}

// ‚îÄ‚îÄ Spy (9/10) ‚îÄ‚îÄ
function doSpyReveal(oppId, oppPos) {
  const gs = gameState;
  const card = gs.hands[oppId][oppPos];
  const lbl = cardLabel(card);
  const opName = gs.playerNames[oppId];
  pendingAction = { ...pendingAction, step:'revealed', oppId, oppPos };
  renderGame();
  showToast(`${opName} Card ${oppPos+1}: ${lbl}${card.suit} = ${card.value}pts`, 3000);
  broadcastEvent({ type:'spy', actorId:myId, actorName:myName, targetId:oppId, targetName:opName, pos:oppPos, cardLabel:`${lbl}${card.suit}` });
  setTimeout(async () => {
    const dc = pendingAction?.drawnCard || gs.drawnCard;
    const updates = {
      drawnCard: null, discard: [...(gameState.discard||[]), dc],
      log: addLog(gameState.log, `<span class="lname">${myName}</span> spied on ${opName}'s card`)
    };
    pendingAction = null;
    Object.assign(updates, nextTurn(gameState));
    await update(ref(db, `rooms/${roomCode}/game`), updates);
  }, 2500);
}

// ‚îÄ‚îÄ Blind Swap (J) ‚îÄ‚îÄ
async function doBlindswapFinish(oppId, oppPos) {
  const gs = gameState;
  const myHand = [...gs.hands[myId]];
  const oppHand = [...gs.hands[oppId]];
  const myPos = pendingAction.myPos;
  [myHand[myPos], oppHand[oppPos]] = [oppHand[oppPos], myHand[myPos]];
  myKnownCards.delete(myPos);
  const opName = gs.playerNames[oppId];
  broadcastEvent({ type:'blindswap', actorId:myId, actorName:myName, targetId:oppId, targetName:opName, myPos, oppPos });
  const updates = {
    drawnCard: null, discard: [...(gs.discard||[]), pendingAction.drawnCard],
    [`hands/${myId}`]: myHand, [`hands/${oppId}`]: oppHand,
    log: addLog(gs.log, `<span class="lname">${myName}</span> blind-swapped with ${opName}`)
  };
  pendingAction = null;
  Object.assign(updates, nextTurn(gs));
  await update(ref(db, `rooms/${roomCode}/game`), updates);
}

// ‚îÄ‚îÄ Peek+Swap (Q) ‚îÄ‚îÄ
function doPeekswapPickOpp(oppId, oppPos) {
  const gs = gameState;
  const card = gs.hands[oppId][oppPos];
  const lbl = cardLabel(card);
  const opName = gs.playerNames[oppId];
  pendingAction = { ...pendingAction, step:'peek-done', oppId, oppPos };
  broadcastEvent({ type:'spy', actorId:myId, actorName:myName, targetId:oppId, targetName:opName, pos:oppPos, cardLabel:`${lbl}${card.suit}` });
  showToast(`${opName} Card ${oppPos+1}: ${lbl}${card.suit} ‚Äî pick YOUR card to swap`, 3000);
  renderGame();
  setTimeout(() => { if (pendingAction) { pendingAction.step='pick-mine'; renderGame(); } }, 2500);
}

async function doPeekswapPickMine(myPos) {
  const gs = gameState;
  const myHand = [...gs.hands[myId]];
  const oppHand = [...gs.hands[pendingAction.oppId]];
  const oppPos = pendingAction.oppPos;
  const oppCard = oppHand[oppPos];
  [myHand[myPos], oppHand[oppPos]] = [oppHand[oppPos], myHand[myPos]];
  myKnownCards.set(myPos, oppCard);
  const opName = gs.playerNames[pendingAction.oppId];
  broadcastEvent({ type:'swap', actorId:myId, actorName:myName, targetId:pendingAction.oppId, targetName:opName, myPos, oppPos });
  const updates = {
    drawnCard:null, discard:[...(gs.discard||[]), pendingAction.drawnCard],
    [`hands/${myId}`]: myHand, [`hands/${pendingAction.oppId}`]: oppHand,
    log: addLog(gs.log, `<span class="lname">${myName}</span> peeked & swapped with ${opName}`)
  };
  pendingAction = null;
  Object.assign(updates, nextTurn(gs));
  await update(ref(db, `rooms/${roomCode}/game`), updates);
}

// ‚îÄ‚îÄ King Swap (K) ‚îÄ‚îÄ
function doKingswapPickOpp(oppId, oppPos) {
  const gs = gameState;
  const card = gs.hands[oppId][oppPos];
  const lbl = cardLabel(card);
  const opName = gs.playerNames[oppId];
  pendingAction = { ...pendingAction, step:'peek-done', oppId, oppPos };
  broadcastEvent({ type:'spy', actorId:myId, actorName:myName, targetId:oppId, targetName:opName, pos:oppPos, cardLabel:`${lbl}${card.suit}` });
  showToast(`${opName} Card ${oppPos+1}: ${lbl}${card.suit} ‚Äî pick YOUR card to peek`, 3000);
  renderGame();
  setTimeout(() => { if (pendingAction) { pendingAction.step='pick-mine'; renderGame(); } }, 2500);
}

function doKingswapPickMine(myPos) {
  const gs = gameState;
  const myCard = gs.hands[myId][myPos];
  const lbl = cardLabel(myCard);
  pendingAction = { ...pendingAction, step:'peek-mine', myPos };
  myKnownCards.set(myPos, myCard);
  broadcastEvent({ type:'peek', actorId:myId, actorName:myName, pos:myPos, cardLabel:`${lbl}${myCard.suit}` });
  showToast(`Your Card ${myPos+1}: ${lbl}${myCard.suit} ‚Äî pick OPPONENT card to swap`, 3000);
  renderGame();
  setTimeout(() => { if (pendingAction) { pendingAction.step='pick-opp-swap'; myKnownCards.delete(myPos); renderGame(); } }, 2500);
}

async function doKingswapSwap(oppId, oppPos) {
  const gs = gameState;
  const myHand = [...gs.hands[myId]];
  const oppHand = [...gs.hands[oppId]];
  const myPos = pendingAction.myPos;
  const oppCard = oppHand[oppPos];
  [myHand[myPos], oppHand[oppPos]] = [oppHand[oppPos], myHand[myPos]];
  myKnownCards.set(myPos, oppCard);
  const opName = gs.playerNames[oppId];
  broadcastEvent({ type:'swap', actorId:myId, actorName:myName, targetId:oppId, targetName:opName, myPos, oppPos });
  const updates = {
    drawnCard:null, discard:[...(gs.discard||[]), pendingAction.drawnCard],
    [`hands/${myId}`]: myHand, [`hands/${oppId}`]: oppHand,
    log: addLog(gs.log, `<span class="lname">${myName}</span> used King swap with ${opName}`)
  };
  pendingAction = null;
  Object.assign(updates, nextTurn(gs));
  await update(ref(db, `rooms/${roomCode}/game`), updates);
}

// ‚îÄ‚îÄ Swap drawn into my hand ‚îÄ‚îÄ
window.swapWithMyCard = async function(pos) {
  if (!isMyTurn() || !gameState.drawnCard) return;
  const gs = gameState;
  const myHand = [...gs.hands[myId]];
  const oldCard = myHand[pos];
  myHand[pos] = gs.drawnCard;
  const lbl = cardLabel(gs.drawnCard);
  myKnownCards.set(pos, gs.drawnCard);
  const updates = {
    drawnCard:null, discard:[...(gs.discard||[]), oldCard],
    [`hands/${myId}`]: myHand,
    log: addLog(gs.log, `<span class="lname">${myName}</span> swapped ${lbl}${gs.drawnCard.suit} into hand`)
  };
  Object.assign(updates, nextTurn(gs));
  await update(ref(db, `rooms/${roomCode}/game`), updates);
};

// ‚îÄ‚îÄ Call CABO ‚îÄ‚îÄ
window.callCabo = async function() {
  if (!isMyTurn() || gameState.caboCallerId || gameState.phase!=='play' || pendingAction) return;
  const gs = gameState;
  const lastTurns = {};
  gs.playerOrder.forEach(pid => { if (pid!==myId) lastTurns[pid]=1; });
  broadcastEvent({ type:'cabo', actorId:myId, actorName:myName });
  const updates = {
    caboCallerId:myId, lastTurns,
    log: addLog(gs.log, `<span class="lname">${myName}</span> <span style="color:var(--accent)">called CABO! üéØ</span>`)
  };
  Object.assign(updates, nextTurn(gs));
  await update(ref(db, `rooms/${roomCode}/game`), updates);
};

function nextTurn(gs) {
  const order = gs.playerOrder;
  const nextPid = order[(order.indexOf(gs.currentTurn)+1) % order.length];
  if (gs.caboCallerId) {
    const lt = { ...(gs.lastTurns||{}) };
    if (lt[gs.currentTurn] !== undefined) lt[gs.currentTurn]--;
    const allDone = order.filter(pid => pid!==gs.caboCallerId).every(pid => !lt[pid]||lt[pid]<=0);
    if (allDone) return { currentTurn:nextPid, phase:'round-end', lastTurns:lt };
    return { currentTurn:nextPid, lastTurns:lt };
  }
  return { currentTurn:nextPid };
}

function addLog(existing, entry) {
  const logs = [...(existing||[])];
  logs.push(entry);
  if (logs.length > 25) logs.shift();
  return logs;
}

// ‚îÄ‚îÄ Round End ‚îÄ‚îÄ
function showRoundEnd() {
  if (document.getElementById('round-modal').classList.contains('open')) return;
  const gs = gameState;
  const results = gs.playerOrder.map(pid => {
    const hand = gs.hands[pid]||[];
    const total = hand.reduce((s,c) => s+(c?.value??0), 0);
    return { pid, name:gs.playerNames[pid], hand, total };
  }).sort((a,b) => a.total-b.total);
  const lowest = results[0].total;
  const cabo = gs.caboCallerId;
  const scored = results.map(r => {
    let pts = r.total;
    if (r.pid===cabo) pts = r.total===lowest ? 0 : r.total+10;
    return { ...r, pts };
  });
  const newScores = { ...(gs.scores||{}) };
  scored.forEach(r => { newScores[r.pid] = (newScores[r.pid]||0) + r.pts; });
  const gameOver = Object.values(newScores).some(s => s>=100);
  let html = '<div class="score-table">';
  scored.forEach(r => {
    const handStr = r.hand.map(c => `${cardLabel(c)}${c.suit}(${c.value})`).join(' ');
    html += `<div class="score-row ${r.pts===0?'winner':''}">
      <span style="font-size:11px">${r.name}${r.pid===cabo?' üì£':''}: ${handStr}</span>
      <span style="white-space:nowrap">+${r.pts}‚Üí${newScores[r.pid]}</span>
    </div>`;
  });
  html += '</div>';
  document.getElementById('round-modal-content').innerHTML = html;
  document.getElementById('next-round-btn').style.display = (isHost&&!gameOver)?'block':'none';
  document.getElementById('round-modal').classList.add('open');
  if (isHost) update(ref(db, `rooms/${roomCode}/game`), { scores:newScores, phase:gameOver?'game-over':'round-end' });
}

function showGameOverModal(scores, names, order) {
  document.getElementById('round-modal').classList.remove('open');
  const sorted = order.map(pid => ({ pid, name:names[pid], score:scores[pid] })).sort((a,b) => a.score-b.score);
  document.getElementById('gameover-title').textContent = `${sorted[0].name} Wins! üéâ`;
  let html = '<div class="score-table">';
  sorted.forEach((p,i) => { html += `<div class="score-row ${i===0?'winner':''}"><span>${i+1}. ${p.name}</span><span>${p.score}pts</span></div>`; });
  html += '</div>';
  document.getElementById('gameover-content').innerHTML = html;
  document.getElementById('game-over-modal').classList.add('open');
}

window.nextRound = async function() {
  if (!isHost) return;
  const gs = gameState;
  const deck = shuffle(buildDeck());
  const hands = {};
  gs.playerOrder.forEach(pid => { hands[pid]=[deck.shift(),deck.shift(),deck.shift(),deck.shift()]; });
  const discard = deck.shift();
  const newGs = { ...gs, deck, discard:[discard], hands, caboCallerId:null, lastTurns:{},
    phase:'initial-peek', drawnCard:null, round:(gs.round||1)+1, log:[], event:null };
  delete newGs.peekReady;
  await set(ref(db, `rooms/${roomCode}/game`), newGs);
  myKnownCards.clear(); initialPeekCount=0; initialPeekDone=false; pendingAction=null;
  censoredCards.clear(); lastEventId=null;
  document.getElementById('round-modal').classList.remove('open');
};

window.closeRoundModal = function() { document.getElementById('round-modal').classList.remove('open'); };
window.playAgain = function() { location.reload(); };

// ‚îÄ‚îÄ Chat ‚îÄ‚îÄ
window.sendChat = async function() {
  const input = document.getElementById('chat-input');
  const text = input.value.trim();
  if (!text || !roomCode) return;
  input.value = '';
  await set(push(ref(db, `rooms/${roomCode}/chat`)), { id:myId, name:myName, text, ts:Date.now() });
};

// ‚îÄ‚îÄ Toast ‚îÄ‚îÄ
function showToast(msg, duration=2000) {
  const t = document.createElement('div');
  t.style.cssText = `position:fixed;bottom:58px;left:50%;transform:translateX(-50%);background:var(--surface2);border:1px solid var(--accent);color:var(--accent);padding:9px 18px;border-radius:8px;font-size:12px;z-index:999;font-family:'DM Mono',monospace;white-space:nowrap;pointer-events:none;`;
  t.textContent = msg;
  document.body.appendChild(t);
  setTimeout(() => t.remove(), duration);
}

function esc(s) { return s.replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;'); }

// ‚îÄ‚îÄ Init ‚îÄ‚îÄ
document.getElementById('player-name-input').addEventListener('keydown', e => { if(e.key==='Enter') setName(); });
document.getElementById('join-code-input').addEventListener('keydown', e => { if(e.key==='Enter') joinRoom(); });
document.getElementById('join-code-input').addEventListener('input', e => { e.target.value = e.target.value.toUpperCase(); });
document.getElementById('chat-input').addEventListener('keydown', e => { if(e.key==='Enter') sendChat(); });

setTimeout(() => {
  document.getElementById('loading').style.display = 'none';
  document.getElementById('lobby').style.display = 'flex';
}, 700);
</script>
</body>
</html>
